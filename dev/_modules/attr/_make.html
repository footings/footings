
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>attr._make &#8212; Footings 0.10.0rc0 documentation</title>
    
  <link rel="stylesheet" href="../../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main">
<div class="container-xl">

    <a class="navbar-brand" href="../../index.html">
    
      <p class="title">Footings</p>
    
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar-menu" class="col-lg-9 collapse navbar-collapse">
      <ul id="navbar-main-elements" class="navbar-nav mr-auto">
        
        
        <li class="nav-item ">
            <a class="nav-link" href="../../installation.html">Installation</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../principles.html">Principles</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../tutorials/index.html">Tutorials</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../api.html">API</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../license.html">License</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../changelog.html">Changelog</a>
        </li>
        
        
      </ul>


      <form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this site..." aria-label="Search this site..." autocomplete="off" >
</form>
      

      <ul class="navbar-nav">
        
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/footings/footings" target="_blank" rel="noopener">
              <span><i class="fab fa-github-square"></i></span>
            </a>
          </li>
        
        
      </ul>
    </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
          <div class="col-12 col-md-3 bd-sidebar"><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

    <div class="bd-toc-item active">
    
  
    <ul class="nav bd-sidenav">
        
        
        
        
        
        
        
        
        
        
        
        
        
      </ul>
  
  </nav>
          </div>
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
              

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
    </ul>
</nav>


              
          </div>
          

          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for attr._make</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">linecache</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_config</span><span class="p">,</span> <span class="n">setters</span>
<span class="kn">from</span> <span class="nn">._compat</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">PY2</span><span class="p">,</span>
    <span class="n">PYPY</span><span class="p">,</span>
    <span class="n">isclass</span><span class="p">,</span>
    <span class="n">iteritems</span><span class="p">,</span>
    <span class="n">metadata_proxy</span><span class="p">,</span>
    <span class="n">ordered_dict</span><span class="p">,</span>
    <span class="n">set_closure_cell</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.exceptions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DefaultAlreadySetError</span><span class="p">,</span>
    <span class="n">FrozenInstanceError</span><span class="p">,</span>
    <span class="n">NotAnAttrsClassError</span><span class="p">,</span>
    <span class="n">PythonTooOldError</span><span class="p">,</span>
    <span class="n">UnannotatedAttributeError</span><span class="p">,</span>
<span class="p">)</span>


<span class="c1"># This is used at least twice, so cache it here.</span>
<span class="n">_obj_setattr</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span>
<span class="n">_init_converter_pat</span> <span class="o">=</span> <span class="s2">&quot;__attr_converter_</span><span class="si">%s</span><span class="s2">&quot;</span>
<span class="n">_init_factory_pat</span> <span class="o">=</span> <span class="s2">&quot;__attr_factory_</span><span class="si">{}</span><span class="s2">&quot;</span>
<span class="n">_tuple_property_pat</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;    </span><span class="si">{attr_name}</span><span class="s2"> = _attrs_property(_attrs_itemgetter(</span><span class="si">{index}</span><span class="s2">))&quot;</span>
<span class="p">)</span>
<span class="n">_classvar_prefixes</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;typing.ClassVar&quot;</span><span class="p">,</span> <span class="s2">&quot;t.ClassVar&quot;</span><span class="p">,</span> <span class="s2">&quot;ClassVar&quot;</span><span class="p">)</span>
<span class="c1"># we don&#39;t use a double-underscore prefix because that triggers</span>
<span class="c1"># name mangling when trying to create a slot for the field</span>
<span class="c1"># (when slots=True)</span>
<span class="n">_hash_cache_field</span> <span class="o">=</span> <span class="s2">&quot;_attrs_cached_hash&quot;</span>

<span class="n">_empty_metadata_singleton</span> <span class="o">=</span> <span class="n">metadata_proxy</span><span class="p">({})</span>

<span class="c1"># Unique object for unequivocal getattr() defaults.</span>
<span class="n">_sentinel</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">_Nothing</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sentinel class to indicate the lack of a value when ``None`` is ambiguous.</span>

<span class="sd">    ``_Nothing`` is a singleton. There is only ever one of it.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_singleton</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_Nothing</span><span class="o">.</span><span class="n">_singleton</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_Nothing</span><span class="o">.</span><span class="n">_singleton</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">_Nothing</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_Nothing</span><span class="o">.</span><span class="n">_singleton</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;NOTHING&quot;</span>


<span class="n">NOTHING</span> <span class="o">=</span> <span class="n">_Nothing</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Sentinel to indicate the lack of a value when ``None`` is ambiguous.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">_CacheHashWrapper</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An integer subclass that pickles / copies as None</span>

<span class="sd">    This is used for non-slots classes with ``cache_hash=True``, to avoid</span>
<span class="sd">    serializing a potentially (even likely) invalid hash value. Since ``None``</span>
<span class="sd">    is the default value for uncalculated hashes, whenever this is copied,</span>
<span class="sd">    the copy&#39;s value for the hash should automatically reset.</span>

<span class="sd">    See GH #613 for more details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">PY2</span><span class="p">:</span>
        <span class="c1"># For some reason `type(None)` isn&#39;t callable in Python 2, but we don&#39;t</span>
        <span class="c1"># actually need a constructor for None objects, we just need any</span>
        <span class="c1"># available function that returns None.</span>
        <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_none_constructor</span><span class="o">=</span><span class="nb">getattr</span><span class="p">,</span> <span class="n">_args</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">_none_constructor</span><span class="p">,</span> <span class="n">_args</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_none_constructor</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">_args</span><span class="o">=</span><span class="p">()):</span>
            <span class="k">return</span> <span class="n">_none_constructor</span><span class="p">,</span> <span class="n">_args</span>


<span class="k">def</span> <span class="nf">attrib</span><span class="p">(</span>
    <span class="n">default</span><span class="o">=</span><span class="n">NOTHING</span><span class="p">,</span>
    <span class="n">validator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="nb">repr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">cmp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="nb">hash</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">converter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">factory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">kw_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">eq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">on_setattr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a new attribute on a class.</span>

<span class="sd">    ..  warning::</span>

<span class="sd">        Does *not* do anything unless the class is also decorated with</span>
<span class="sd">        `attr.s`!</span>

<span class="sd">    :param default: A value that is used if an ``attrs``-generated ``__init__``</span>
<span class="sd">        is used and no value is passed while instantiating or the attribute is</span>
<span class="sd">        excluded using ``init=False``.</span>

<span class="sd">        If the value is an instance of `Factory`, its callable will be</span>
<span class="sd">        used to construct a new value (useful for mutable data types like lists</span>
<span class="sd">        or dicts).</span>

<span class="sd">        If a default is not set (or set manually to `attr.NOTHING`), a value</span>
<span class="sd">        *must* be supplied when instantiating; otherwise a `TypeError`</span>
<span class="sd">        will be raised.</span>

<span class="sd">        The default can also be set using decorator notation as shown below.</span>

<span class="sd">    :type default: Any value</span>

<span class="sd">    :param callable factory: Syntactic sugar for</span>
<span class="sd">        ``default=attr.Factory(factory)``.</span>

<span class="sd">    :param validator: `callable` that is called by ``attrs``-generated</span>
<span class="sd">        ``__init__`` methods after the instance has been initialized.  They</span>
<span class="sd">        receive the initialized instance, the `Attribute`, and the</span>
<span class="sd">        passed value.</span>

<span class="sd">        The return value is *not* inspected so the validator has to throw an</span>
<span class="sd">        exception itself.</span>

<span class="sd">        If a `list` is passed, its items are treated as validators and must</span>
<span class="sd">        all pass.</span>

<span class="sd">        Validators can be globally disabled and re-enabled using</span>
<span class="sd">        `get_run_validators`.</span>

<span class="sd">        The validator can also be set using decorator notation as shown below.</span>

<span class="sd">    :type validator: `callable` or a `list` of `callable`\\ s.</span>

<span class="sd">    :param repr: Include this attribute in the generated ``__repr__``</span>
<span class="sd">        method. If ``True``, include the attribute; if ``False``, omit it. By</span>
<span class="sd">        default, the built-in ``repr()`` function is used. To override how the</span>
<span class="sd">        attribute value is formatted, pass a ``callable`` that takes a single</span>
<span class="sd">        value and returns a string. Note that the resulting string is used</span>
<span class="sd">        as-is, i.e. it will be used directly *instead* of calling ``repr()``</span>
<span class="sd">        (the default).</span>
<span class="sd">    :type repr: a `bool` or a `callable` to use a custom function.</span>
<span class="sd">    :param bool eq: If ``True`` (default), include this attribute in the</span>
<span class="sd">        generated ``__eq__`` and ``__ne__`` methods that check two instances</span>
<span class="sd">        for equality.</span>
<span class="sd">    :param bool order: If ``True`` (default), include this attributes in the</span>
<span class="sd">        generated ``__lt__``, ``__le__``, ``__gt__`` and ``__ge__`` methods.</span>
<span class="sd">    :param bool cmp: Setting to ``True`` is equivalent to setting ``eq=True,</span>
<span class="sd">        order=True``. Deprecated in favor of *eq* and *order*.</span>
<span class="sd">    :param Optional[bool] hash: Include this attribute in the generated</span>
<span class="sd">        ``__hash__`` method.  If ``None`` (default), mirror *eq*&#39;s value.  This</span>
<span class="sd">        is the correct behavior according the Python spec.  Setting this value</span>
<span class="sd">        to anything else than ``None`` is *discouraged*.</span>
<span class="sd">    :param bool init: Include this attribute in the generated ``__init__``</span>
<span class="sd">        method.  It is possible to set this to ``False`` and set a default</span>
<span class="sd">        value.  In that case this attributed is unconditionally initialized</span>
<span class="sd">        with the specified default value or factory.</span>
<span class="sd">    :param callable converter: `callable` that is called by</span>
<span class="sd">        ``attrs``-generated ``__init__`` methods to convert attribute&#39;s value</span>
<span class="sd">        to the desired format.  It is given the passed-in value, and the</span>
<span class="sd">        returned value will be used as the new value of the attribute.  The</span>
<span class="sd">        value is converted before being passed to the validator, if any.</span>
<span class="sd">    :param metadata: An arbitrary mapping, to be used by third-party</span>
<span class="sd">        components.  See `extending_metadata`.</span>
<span class="sd">    :param type: The type of the attribute.  In Python 3.6 or greater, the</span>
<span class="sd">        preferred method to specify the type is using a variable annotation</span>
<span class="sd">        (see `PEP 526 &lt;https://www.python.org/dev/peps/pep-0526/&gt;`_).</span>
<span class="sd">        This argument is provided for backward compatibility.</span>
<span class="sd">        Regardless of the approach used, the type will be stored on</span>
<span class="sd">        ``Attribute.type``.</span>

<span class="sd">        Please note that ``attrs`` doesn&#39;t do anything with this metadata by</span>
<span class="sd">        itself. You can use it as part of your own code or for</span>
<span class="sd">        `static type checking &lt;types&gt;`.</span>
<span class="sd">    :param kw_only: Make this attribute keyword-only (Python 3+)</span>
<span class="sd">        in the generated ``__init__`` (if ``init`` is ``False``, this</span>
<span class="sd">        parameter is ignored).</span>
<span class="sd">    :param on_setattr: Allows to overwrite the *on_setattr* setting from</span>
<span class="sd">        `attr.s`. If left `None`, the *on_setattr* value from `attr.s` is used.</span>
<span class="sd">        Set to `attr.setters.NO_OP` to run **no** `setattr` hooks for this</span>
<span class="sd">        attribute -- regardless of the setting in `attr.s`.</span>
<span class="sd">    :type on_setattr: `callable`, or a list of callables, or `None`, or</span>
<span class="sd">        `attr.setters.NO_OP`</span>

<span class="sd">    .. versionadded:: 15.2.0 *convert*</span>
<span class="sd">    .. versionadded:: 16.3.0 *metadata*</span>
<span class="sd">    .. versionchanged:: 17.1.0 *validator* can be a ``list`` now.</span>
<span class="sd">    .. versionchanged:: 17.1.0</span>
<span class="sd">       *hash* is ``None`` and therefore mirrors *eq* by default.</span>
<span class="sd">    .. versionadded:: 17.3.0 *type*</span>
<span class="sd">    .. deprecated:: 17.4.0 *convert*</span>
<span class="sd">    .. versionadded:: 17.4.0 *converter* as a replacement for the deprecated</span>
<span class="sd">       *convert* to achieve consistency with other noun-based arguments.</span>
<span class="sd">    .. versionadded:: 18.1.0</span>
<span class="sd">       ``factory=f`` is syntactic sugar for ``default=attr.Factory(f)``.</span>
<span class="sd">    .. versionadded:: 18.2.0 *kw_only*</span>
<span class="sd">    .. versionchanged:: 19.2.0 *convert* keyword argument removed</span>
<span class="sd">    .. versionchanged:: 19.2.0 *repr* also accepts a custom callable.</span>
<span class="sd">    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.</span>
<span class="sd">    .. versionadded:: 19.2.0 *eq* and *order*</span>
<span class="sd">    .. versionadded:: 20.1.0 *on_setattr*</span>
<span class="sd">    .. versionchanged:: 20.3.0 *kw_only* backported to Python 2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eq</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">_determine_eq_order</span><span class="p">(</span><span class="n">cmp</span><span class="p">,</span> <span class="n">eq</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">hash</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hash</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span> <span class="ow">and</span> <span class="nb">hash</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Invalid value for hash.  Must be True, False, or None.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">factory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">NOTHING</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The `default` and `factory` arguments are mutually &quot;</span>
                <span class="s2">&quot;exclusive.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">factory</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The `factory` argument must be a callable.&quot;</span><span class="p">)</span>
        <span class="n">default</span> <span class="o">=</span> <span class="n">Factory</span><span class="p">(</span><span class="n">factory</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Apply syntactic sugar by auto-wrapping.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">on_setattr</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">on_setattr</span> <span class="o">=</span> <span class="n">setters</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="o">*</span><span class="n">on_setattr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">validator</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">validator</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">validator</span> <span class="o">=</span> <span class="n">and_</span><span class="p">(</span><span class="o">*</span><span class="n">validator</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">converter</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">converter</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">converter</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">(</span><span class="o">*</span><span class="n">converter</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_CountingAttr</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span>
        <span class="n">validator</span><span class="o">=</span><span class="n">validator</span><span class="p">,</span>
        <span class="nb">repr</span><span class="o">=</span><span class="nb">repr</span><span class="p">,</span>
        <span class="n">cmp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">hash</span><span class="o">=</span><span class="nb">hash</span><span class="p">,</span>
        <span class="n">init</span><span class="o">=</span><span class="n">init</span><span class="p">,</span>
        <span class="n">converter</span><span class="o">=</span><span class="n">converter</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
        <span class="n">kw_only</span><span class="o">=</span><span class="n">kw_only</span><span class="p">,</span>
        <span class="n">eq</span><span class="o">=</span><span class="n">eq</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
        <span class="n">on_setattr</span><span class="o">=</span><span class="n">on_setattr</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_make_attr_tuple_class</span><span class="p">(</span><span class="n">cls_name</span><span class="p">,</span> <span class="n">attr_names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a tuple subclass to hold `Attribute`s for an `attrs` class.</span>

<span class="sd">    The subclass is a bare tuple with properties for names.</span>

<span class="sd">    class MyClassAttributes(tuple):</span>
<span class="sd">        __slots__ = ()</span>
<span class="sd">        x = property(itemgetter(0))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attr_class_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">Attributes&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cls_name</span><span class="p">)</span>
    <span class="n">attr_class_template</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;class </span><span class="si">{}</span><span class="s2">(tuple):&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attr_class_name</span><span class="p">),</span>
        <span class="s2">&quot;    __slots__ = ()&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="n">attr_names</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">attr_names</span><span class="p">):</span>
            <span class="n">attr_class_template</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">_tuple_property_pat</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">attr_name</span><span class="o">=</span><span class="n">attr_name</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">attr_class_template</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;    pass&quot;</span><span class="p">)</span>
    <span class="n">globs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_attrs_itemgetter&quot;</span><span class="p">:</span> <span class="n">itemgetter</span><span class="p">,</span> <span class="s2">&quot;_attrs_property&quot;</span><span class="p">:</span> <span class="nb">property</span><span class="p">}</span>
    <span class="nb">eval</span><span class="p">(</span><span class="nb">compile</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">attr_class_template</span><span class="p">),</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;exec&quot;</span><span class="p">),</span> <span class="n">globs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">globs</span><span class="p">[</span><span class="n">attr_class_name</span><span class="p">]</span>


<span class="c1"># Tuple class for extracted attributes from a class definition.</span>
<span class="c1"># `base_attrs` is a subset of `attrs`.</span>
<span class="n">_Attributes</span> <span class="o">=</span> <span class="n">_make_attr_tuple_class</span><span class="p">(</span>
    <span class="s2">&quot;_Attributes&quot;</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="c1"># all attributes to build dunder methods for</span>
        <span class="s2">&quot;attrs&quot;</span><span class="p">,</span>
        <span class="c1"># attributes that have been inherited</span>
        <span class="s2">&quot;base_attrs&quot;</span><span class="p">,</span>
        <span class="c1"># map inherited attributes to their originating classes</span>
        <span class="s2">&quot;base_attrs_map&quot;</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_class_var</span><span class="p">(</span><span class="n">annot</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether *annot* is a typing.ClassVar.</span>

<span class="sd">    The string comparison hack is used to avoid evaluating all string</span>
<span class="sd">    annotations which would put attrs-based classes at a performance</span>
<span class="sd">    disadvantage compared to plain old classes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">annot</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">_classvar_prefixes</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_has_own_attribute</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attrib_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether *cls* defines *attrib_name* (and doesn&#39;t just inherit it).</span>

<span class="sd">    Requires Python 3.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attrib_name</span><span class="p">,</span> <span class="n">_sentinel</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="n">_sentinel</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">for</span> <span class="n">base_cls</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base_cls</span><span class="p">,</span> <span class="n">attrib_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="n">a</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">_get_annotations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get annotations for *cls*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_has_own_attribute</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__annotations__&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__annotations__</span>

    <span class="k">return</span> <span class="p">{}</span>


<span class="k">def</span> <span class="nf">_counter_getter</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Key function for sorting to avoid re-creating a lambda for every class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">counter</span>


<span class="k">def</span> <span class="nf">_collect_base_attrs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">taken_attr_names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collect attr.ibs from base classes of *cls*, except *taken_attr_names*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_attrs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">base_attr_map</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># A dictionary of base attrs to their classes.</span>

    <span class="c1"># Traverse the MRO and collect attributes.</span>
    <span class="k">for</span> <span class="n">base_cls</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base_cls</span><span class="p">,</span> <span class="s2">&quot;__attrs_attrs__&quot;</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">inherited</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">taken_attr_names</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">inherited</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">base_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">base_attr_map</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_cls</span>

    <span class="c1"># For each name, only keep the freshest definition i.e. the furthest at the</span>
    <span class="c1"># back.  base_attr_map is fine because it gets overwritten with every new</span>
    <span class="c1"># instance.</span>
    <span class="n">filtered</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">base_attrs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">filtered</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">filtered</span><span class="p">,</span> <span class="n">base_attr_map</span>


<span class="k">def</span> <span class="nf">_collect_base_attrs_broken</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">taken_attr_names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collect attr.ibs from base classes of *cls*, except *taken_attr_names*.</span>

<span class="sd">    N.B. *taken_attr_names* will be mutated.</span>

<span class="sd">    Adhere to the old incorrect behavior.</span>

<span class="sd">    Notably it collects from the front and considers inherited attributes which</span>
<span class="sd">    leads to the buggy behavior reported in #428.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base_attrs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">base_attr_map</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># A dictionary of base attrs to their classes.</span>

    <span class="c1"># Traverse the MRO and collect attributes.</span>
    <span class="k">for</span> <span class="n">base_cls</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base_cls</span><span class="p">,</span> <span class="s2">&quot;__attrs_attrs__&quot;</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">taken_attr_names</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">inherited</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">taken_attr_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">base_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">base_attr_map</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_cls</span>

    <span class="k">return</span> <span class="n">base_attrs</span><span class="p">,</span> <span class="n">base_attr_map</span>


<span class="k">def</span> <span class="nf">_transform_attrs</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span> <span class="n">these</span><span class="p">,</span> <span class="n">auto_attribs</span><span class="p">,</span> <span class="n">kw_only</span><span class="p">,</span> <span class="n">collect_by_mro</span><span class="p">,</span> <span class="n">field_transformer</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform all `_CountingAttr`s on a class into `Attribute`s.</span>

<span class="sd">    If *these* is passed, use that and don&#39;t look for them on the class.</span>

<span class="sd">    *collect_by_mro* is True, collect them in the correct MRO order, otherwise</span>
<span class="sd">    use the old -- incorrect -- order.  See #428.</span>

<span class="sd">    Return an `_Attributes`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cd</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span>
    <span class="n">anns</span> <span class="o">=</span> <span class="n">_get_annotations</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">these</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ca_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">ca</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">ca</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">these</span><span class="p">)]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">these</span><span class="p">,</span> <span class="n">ordered_dict</span><span class="p">):</span>
            <span class="n">ca_list</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">_counter_getter</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">auto_attribs</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">ca_names</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">cd</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">_CountingAttr</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">ca_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">annot_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">attr_name</span><span class="p">,</span> <span class="nb">type</span> <span class="ow">in</span> <span class="n">anns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">_is_class_var</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="n">annot_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">attr_name</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">cd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">NOTHING</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_CountingAttr</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="n">NOTHING</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">a</span><span class="p">)</span>
            <span class="n">ca_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>

        <span class="n">unannotated</span> <span class="o">=</span> <span class="n">ca_names</span> <span class="o">-</span> <span class="n">annot_names</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unannotated</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">UnannotatedAttributeError</span><span class="p">(</span>
                <span class="s2">&quot;The following `attr.ib`s lack a type annotation: &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="nb">sorted</span><span class="p">(</span><span class="n">unannotated</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">cd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">counter</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;.&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ca_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">cd</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">_CountingAttr</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">counter</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">own_attrs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">Attribute</span><span class="o">.</span><span class="n">from_counting_attr</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">ca</span><span class="o">=</span><span class="n">ca</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">anns</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attr_name</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">ca</span> <span class="ow">in</span> <span class="n">ca_list</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="n">collect_by_mro</span><span class="p">:</span>
        <span class="n">base_attrs</span><span class="p">,</span> <span class="n">base_attr_map</span> <span class="o">=</span> <span class="n">_collect_base_attrs</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="p">{</span><span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">own_attrs</span><span class="p">}</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">base_attrs</span><span class="p">,</span> <span class="n">base_attr_map</span> <span class="o">=</span> <span class="n">_collect_base_attrs_broken</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="p">{</span><span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">own_attrs</span><span class="p">}</span>
        <span class="p">)</span>

    <span class="n">attr_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">base_attrs</span> <span class="o">+</span> <span class="n">own_attrs</span><span class="p">]</span>

    <span class="n">AttrsClass</span> <span class="o">=</span> <span class="n">_make_attr_tuple_class</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr_names</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">kw_only</span><span class="p">:</span>
        <span class="n">own_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">kw_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">own_attrs</span><span class="p">]</span>
        <span class="n">base_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">evolve</span><span class="p">(</span><span class="n">kw_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">base_attrs</span><span class="p">]</span>

    <span class="n">attrs</span> <span class="o">=</span> <span class="n">AttrsClass</span><span class="p">(</span><span class="n">base_attrs</span> <span class="o">+</span> <span class="n">own_attrs</span><span class="p">)</span>

    <span class="c1"># Mandatory vs non-mandatory attr order only matters when they are part of</span>
    <span class="c1"># the __init__ signature and when they aren&#39;t kw_only (which are moved to</span>
    <span class="c1"># the end and can be mandatory or non-mandatory in any order, as they will</span>
    <span class="c1"># be specified as keyword args anyway). Check the order of those attrs:</span>
    <span class="n">had_default</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">kw_only</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">had_default</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">NOTHING</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No mandatory attributes allowed after an attribute with a &quot;</span>
                <span class="s2">&quot;default value or factory.  Attribute in question: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">had_default</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">NOTHING</span><span class="p">:</span>
            <span class="n">had_default</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">field_transformer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="n">field_transformer</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_Attributes</span><span class="p">((</span><span class="n">attrs</span><span class="p">,</span> <span class="n">base_attrs</span><span class="p">,</span> <span class="n">base_attr_map</span><span class="p">))</span>


<span class="k">if</span> <span class="n">PYPY</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">_frozen_setattrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attached to frozen classes as __setattr__.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="ne">BaseException</span><span class="p">)</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="s2">&quot;__cause__&quot;</span><span class="p">,</span>
            <span class="s2">&quot;__context__&quot;</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="ne">BaseException</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">raise</span> <span class="n">FrozenInstanceError</span><span class="p">()</span>


<span class="k">else</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">_frozen_setattrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attached to frozen classes as __setattr__.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="n">FrozenInstanceError</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_frozen_delattrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attached to frozen classes as __delattr__.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="n">FrozenInstanceError</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">_ClassBuilder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iteratively build *one* class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;_attr_names&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_attrs&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_base_attr_map&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_base_names&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_cache_hash&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_cls&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_cls_dict&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_delete_attribs&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_frozen&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_has_post_init&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_is_exc&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_on_setattr&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_slots&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_weakref_slot&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_has_own_setattr&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_has_custom_setattr&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">these</span><span class="p">,</span>
        <span class="n">slots</span><span class="p">,</span>
        <span class="n">frozen</span><span class="p">,</span>
        <span class="n">weakref_slot</span><span class="p">,</span>
        <span class="n">getstate_setstate</span><span class="p">,</span>
        <span class="n">auto_attribs</span><span class="p">,</span>
        <span class="n">kw_only</span><span class="p">,</span>
        <span class="n">cache_hash</span><span class="p">,</span>
        <span class="n">is_exc</span><span class="p">,</span>
        <span class="n">collect_by_mro</span><span class="p">,</span>
        <span class="n">on_setattr</span><span class="p">,</span>
        <span class="n">has_custom_setattr</span><span class="p">,</span>
        <span class="n">field_transformer</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">attrs</span><span class="p">,</span> <span class="n">base_attrs</span><span class="p">,</span> <span class="n">base_map</span> <span class="o">=</span> <span class="n">_transform_attrs</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="n">these</span><span class="p">,</span>
            <span class="n">auto_attribs</span><span class="p">,</span>
            <span class="n">kw_only</span><span class="p">,</span>
            <span class="n">collect_by_mro</span><span class="p">,</span>
            <span class="n">field_transformer</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cls</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span> <span class="k">if</span> <span class="n">slots</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="o">=</span> <span class="n">attrs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">base_attrs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_attr_map</span> <span class="o">=</span> <span class="n">base_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attr_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span> <span class="o">=</span> <span class="n">slots</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span> <span class="o">=</span> <span class="n">frozen</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weakref_slot</span> <span class="o">=</span> <span class="n">weakref_slot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache_hash</span> <span class="o">=</span> <span class="n">cache_hash</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_post_init</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__attrs_post_init__&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_delete_attribs</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">these</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_exc</span> <span class="o">=</span> <span class="n">is_exc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_on_setattr</span> <span class="o">=</span> <span class="n">on_setattr</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_has_custom_setattr</span> <span class="o">=</span> <span class="n">has_custom_setattr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_own_setattr</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span><span class="p">[</span><span class="s2">&quot;__attrs_attrs__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span>

        <span class="k">if</span> <span class="n">frozen</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span><span class="p">[</span><span class="s2">&quot;__setattr__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_frozen_setattrs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span><span class="p">[</span><span class="s2">&quot;__delattr__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_frozen_delattrs</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_has_own_setattr</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">getstate_setstate</span><span class="p">:</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span><span class="p">[</span><span class="s2">&quot;__getstate__&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span><span class="p">[</span><span class="s2">&quot;__setstate__&quot;</span><span class="p">],</span>
            <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_getstate_setstate</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;_ClassBuilder(cls=</span><span class="si">{cls}</span><span class="s2">)&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">build_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finalize class based on the accumulated configuration.</span>

<span class="sd">        Builder cannot be used after calling this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_slots_class</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patch_original_class</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_patch_original_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply accumulated methods and return the class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls</span>
        <span class="n">base_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_names</span>

        <span class="c1"># Clean class of attribute definitions (`attr.ib()`s).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delete_attribs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">base_names</span>
                    <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">_sentinel</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_sentinel</span>
                <span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="nb">delattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="c1"># This can happen if a base class defines a class</span>
                        <span class="c1"># variable and we want to set an attribute with the</span>
                        <span class="c1"># same name by using only a type annotation.</span>
                        <span class="k">pass</span>

        <span class="c1"># Attach our dunder methods.</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># If we&#39;ve inherited an attrs __setattr__ and don&#39;t write our own,</span>
        <span class="c1"># reset it to object&#39;s.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_own_setattr</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__attrs_own_setattr__&quot;</span><span class="p">,</span> <span class="kc">False</span>
        <span class="p">):</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">__attrs_own_setattr__</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_custom_setattr</span><span class="p">:</span>
                <span class="bp">cls</span><span class="o">.</span><span class="fm">__setattr__</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span>

        <span class="k">return</span> <span class="bp">cls</span>

    <span class="k">def</span> <span class="nf">_create_slots_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build and return a new class with a `__slots__` attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_names</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attr_names</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;__dict__&quot;</span><span class="p">,</span> <span class="s2">&quot;__weakref__&quot;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1"># If our class doesn&#39;t have its own implementation of __setattr__</span>
        <span class="c1"># (either from the user or by us), check the bases, if one of them has</span>
        <span class="c1"># an attrs-made __setattr__, that needs to be reset. We don&#39;t walk the</span>
        <span class="c1"># MRO because we only care about our immediate base classes.</span>
        <span class="c1"># XXX: This can be confused by subclassing a slotted attrs class with</span>
        <span class="c1"># XXX: a non-attrs class and subclass the resulting class with an attrs</span>
        <span class="c1"># XXX: class.  See `test_slotted_confused` for details.  For now that&#39;s</span>
        <span class="c1"># XXX: OK with us.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_own_setattr</span><span class="p">:</span>
            <span class="n">cd</span><span class="p">[</span><span class="s2">&quot;__attrs_own_setattr__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_custom_setattr</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">base_cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">base_cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;__attrs_own_setattr__&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                        <span class="n">cd</span><span class="p">[</span><span class="s2">&quot;__setattr__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span>
                        <span class="k">break</span>

        <span class="c1"># Traverse the MRO to check for an existing __weakref__.</span>
        <span class="n">weakref_inherited</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">base_cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">base_cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;__weakref__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">weakref_inherited</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr_names</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_weakref_slot</span>
            <span class="ow">and</span> <span class="s2">&quot;__weakref__&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="p">,</span> <span class="s2">&quot;__slots__&quot;</span><span class="p">,</span> <span class="p">())</span>
            <span class="ow">and</span> <span class="s2">&quot;__weakref__&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">weakref_inherited</span>
        <span class="p">):</span>
            <span class="n">names</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;__weakref__&quot;</span><span class="p">,)</span>

        <span class="c1"># We only add the names of attributes that aren&#39;t inherited.</span>
        <span class="c1"># Setting __slots__ to inherited attributes wastes memory.</span>
        <span class="n">slot_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">base_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_hash</span><span class="p">:</span>
            <span class="n">slot_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_hash_cache_field</span><span class="p">)</span>
        <span class="n">cd</span><span class="p">[</span><span class="s2">&quot;__slots__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slot_names</span><span class="p">)</span>

        <span class="n">qualname</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">qualname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cd</span><span class="p">[</span><span class="s2">&quot;__qualname__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qualname</span>

        <span class="c1"># Create new class based on old class and our methods.</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">,</span> <span class="n">cd</span><span class="p">)</span>

        <span class="c1"># The following is a fix for</span>
        <span class="c1"># https://github.com/python-attrs/attrs/issues/102.  On Python 3,</span>
        <span class="c1"># if a method mentions `__class__` or uses the no-arg super(), the</span>
        <span class="c1"># compiler will bake a reference to the class in the method itself</span>
        <span class="c1"># as `method.__closure__`.  Since we replace the class with a</span>
        <span class="c1"># clone, we rewrite these references so it keeps working.</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">classmethod</span><span class="p">,</span> <span class="nb">staticmethod</span><span class="p">)):</span>
                <span class="c1"># Class- and staticmethods hide their functions inside.</span>
                <span class="c1"># These might need to be rewritten as well.</span>
                <span class="n">closure_cells</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="vm">__func__</span><span class="p">,</span> <span class="s2">&quot;__closure__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">closure_cells</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="s2">&quot;__closure__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">closure_cells</span><span class="p">:</span>  <span class="c1"># Catch None or the empty list.</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">closure_cells</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">cell_contents</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># ValueError: Cell is empty</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                        <span class="n">set_closure_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span>

    <span class="k">def</span> <span class="nf">add_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span><span class="p">[</span><span class="s2">&quot;__repr__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_method_dunders</span><span class="p">(</span>
            <span class="n">_make_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span> <span class="n">ns</span><span class="o">=</span><span class="n">ns</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">repr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;__repr__&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">repr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;__str__ can only be generated if a __repr__ exists.&quot;</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span><span class="p">[</span><span class="s2">&quot;__str__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_method_dunders</span><span class="p">(</span><span class="fm">__str__</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_make_getstate_setstate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create custom __setstate__ and __getstate__ methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># __weakref__ is not writable.</span>
        <span class="n">state_attr_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">an</span> <span class="k">for</span> <span class="n">an</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr_names</span> <span class="k">if</span> <span class="n">an</span> <span class="o">!=</span> <span class="s2">&quot;__weakref__&quot;</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">slots_getstate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Automatically created by attrs.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">state_attr_names</span><span class="p">)</span>

        <span class="n">hash_caching_enabled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cache_hash</span>

        <span class="k">def</span> <span class="nf">slots_setstate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Automatically created by attrs.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">__bound_setattr</span> <span class="o">=</span> <span class="n">_obj_setattr</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Attribute</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">state_attr_names</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
                <span class="n">__bound_setattr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

            <span class="c1"># The hash code cache is not included when the object is</span>
            <span class="c1"># serialized, but it still needs to be initialized to None to</span>
            <span class="c1"># indicate that the first call to __hash__ should be a cache</span>
            <span class="c1"># miss.</span>
            <span class="k">if</span> <span class="n">hash_caching_enabled</span><span class="p">:</span>
                <span class="n">__bound_setattr</span><span class="p">(</span><span class="n">_hash_cache_field</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">slots_getstate</span><span class="p">,</span> <span class="n">slots_setstate</span>

    <span class="k">def</span> <span class="nf">make_unhashable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span><span class="p">[</span><span class="s2">&quot;__hash__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span><span class="p">[</span><span class="s2">&quot;__hash__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_method_dunders</span><span class="p">(</span>
            <span class="n">_make_hash</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
                <span class="n">frozen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">,</span>
                <span class="n">cache_hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cache_hash</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span><span class="p">[</span><span class="s2">&quot;__init__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_method_dunders</span><span class="p">(</span>
            <span class="n">_make_init</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_post_init</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cache_hash</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_base_attr_map</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_exc</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_on_setattr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_setattr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">setters</span><span class="o">.</span><span class="n">NO_OP</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span>

        <span class="n">cd</span><span class="p">[</span><span class="s2">&quot;__eq__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_method_dunders</span><span class="p">(</span>
            <span class="n">_make_eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">cd</span><span class="p">[</span><span class="s2">&quot;__ne__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_method_dunders</span><span class="p">(</span><span class="n">_make_ne</span><span class="p">())</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span>

        <span class="n">cd</span><span class="p">[</span><span class="s2">&quot;__lt__&quot;</span><span class="p">],</span> <span class="n">cd</span><span class="p">[</span><span class="s2">&quot;__le__&quot;</span><span class="p">],</span> <span class="n">cd</span><span class="p">[</span><span class="s2">&quot;__gt__&quot;</span><span class="p">],</span> <span class="n">cd</span><span class="p">[</span><span class="s2">&quot;__ge__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_method_dunders</span><span class="p">(</span><span class="n">meth</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">meth</span> <span class="ow">in</span> <span class="n">_make_order</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">add_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">sa_attrs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">:</span>
            <span class="n">on_setattr</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">on_setattr</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_setattr</span>
            <span class="k">if</span> <span class="n">on_setattr</span> <span class="ow">and</span> <span class="n">on_setattr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">setters</span><span class="o">.</span><span class="n">NO_OP</span><span class="p">:</span>
                <span class="n">sa_attrs</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">on_setattr</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sa_attrs</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_custom_setattr</span><span class="p">:</span>
            <span class="c1"># We need to write a __setattr__ but there already is one!</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Can&#39;t combine custom __setattr__ with on_setattr hooks.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># docstring comes from _add_method_dunders</span>
        <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">hook</span> <span class="o">=</span> <span class="n">sa_attrs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">nval</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nval</span> <span class="o">=</span> <span class="n">hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

            <span class="n">_obj_setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">nval</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span><span class="p">[</span><span class="s2">&quot;__attrs_own_setattr__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cls_dict</span><span class="p">[</span><span class="s2">&quot;__setattr__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_method_dunders</span><span class="p">(</span><span class="fm">__setattr__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_own_setattr</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_add_method_dunders</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add __module__ and __qualname__ to a *method* if possible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">method</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="o">.</span><span class="vm">__module__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">method</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">,</span> <span class="n">method</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">method</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;Method generated by attrs for class </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cls</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">method</span>


<span class="n">_CMP_DEPRECATION</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;The usage of `cmp` is deprecated and will be removed on or after &quot;</span>
    <span class="s2">&quot;2021-06-01.  Please use `eq` and `order` instead.&quot;</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">_determine_eq_order</span><span class="p">(</span><span class="n">cmp</span><span class="p">,</span> <span class="n">eq</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">default_eq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate the combination of *cmp*, *eq*, and *order*. Derive the effective</span>
<span class="sd">    values of eq and order.  If *eq* is None, set it to *default_eq*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cmp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">((</span><span class="n">eq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Don&#39;t mix `cmp` with `eq&#39; and `order`.&quot;</span><span class="p">)</span>

    <span class="c1"># cmp takes precedence due to bw-compatibility.</span>
    <span class="k">if</span> <span class="n">cmp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">_CMP_DEPRECATION</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cmp</span><span class="p">,</span> <span class="n">cmp</span>

    <span class="c1"># If left None, equality is set to the specified default and ordering</span>
    <span class="c1"># mirrors equality.</span>
    <span class="k">if</span> <span class="n">eq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">default_eq</span>

    <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">eq</span>

    <span class="k">if</span> <span class="n">eq</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`order` can only be True if `eq` is True too.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">eq</span><span class="p">,</span> <span class="n">order</span>


<span class="k">def</span> <span class="nf">_determine_whether_to_implement</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="n">auto_detect</span><span class="p">,</span> <span class="n">dunders</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether we should implement a set of methods for *cls*.</span>

<span class="sd">    *flag* is the argument passed into @attr.s like &#39;init&#39;, *auto_detect* the</span>
<span class="sd">    same as passed into @attr.s and *dunders* is a tuple of attribute names</span>
<span class="sd">    whose presence signal that the user has implemented it themselves.</span>

<span class="sd">    Return *default* if no reason for either for or against is found.</span>

<span class="sd">    auto_detect must be False on Python 2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">flag</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="n">flag</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flag</span>

    <span class="k">if</span> <span class="n">flag</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">auto_detect</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>

    <span class="c1"># Logically, flag is None and auto_detect is True here.</span>
    <span class="k">for</span> <span class="n">dunder</span> <span class="ow">in</span> <span class="n">dunders</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">_has_own_attribute</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dunder</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">default</span>


<span class="k">def</span> <span class="nf">attrs</span><span class="p">(</span>
    <span class="n">maybe_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">these</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">repr_ns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="nb">repr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cmp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="nb">hash</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">slots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">frozen</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">weakref_slot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="nb">str</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">auto_attribs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">kw_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">cache_hash</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">auto_exc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">eq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">auto_detect</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">collect_by_mro</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">getstate_setstate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">on_setattr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">field_transformer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class decorator that adds `dunder</span>
<span class="sd">    &lt;https://wiki.python.org/moin/DunderAlias&gt;`_\ -methods according to the</span>
<span class="sd">    specified attributes using `attr.ib` or the *these* argument.</span>

<span class="sd">    :param these: A dictionary of name to `attr.ib` mappings.  This is</span>
<span class="sd">        useful to avoid the definition of your attributes within the class body</span>
<span class="sd">        because you can&#39;t (e.g. if you want to add ``__repr__`` methods to</span>
<span class="sd">        Django models) or don&#39;t want to.</span>

<span class="sd">        If *these* is not ``None``, ``attrs`` will *not* search the class body</span>
<span class="sd">        for attributes and will *not* remove any attributes from it.</span>

<span class="sd">        If *these* is an ordered dict (`dict` on Python 3.6+,</span>
<span class="sd">        `collections.OrderedDict` otherwise), the order is deduced from</span>
<span class="sd">        the order of the attributes inside *these*.  Otherwise the order</span>
<span class="sd">        of the definition of the attributes is used.</span>

<span class="sd">    :type these: `dict` of `str` to `attr.ib`</span>

<span class="sd">    :param str repr_ns: When using nested classes, there&#39;s no way in Python 2</span>
<span class="sd">        to automatically detect that.  Therefore it&#39;s possible to set the</span>
<span class="sd">        namespace explicitly for a more meaningful ``repr`` output.</span>
<span class="sd">    :param bool auto_detect: Instead of setting the *init*, *repr*, *eq*,</span>
<span class="sd">        *order*, and *hash* arguments explicitly, assume they are set to</span>
<span class="sd">        ``True`` **unless any** of the involved methods for one of the</span>
<span class="sd">        arguments is implemented in the *current* class (i.e. it is *not*</span>
<span class="sd">        inherited from some base class).</span>

<span class="sd">        So for example by implementing ``__eq__`` on a class yourself,</span>
<span class="sd">        ``attrs`` will deduce ``eq=False`` and won&#39;t create *neither*</span>
<span class="sd">        ``__eq__`` *nor* ``__ne__`` (but Python classes come with a sensible</span>
<span class="sd">        ``__ne__`` by default, so it *should* be enough to only implement</span>
<span class="sd">        ``__eq__`` in most cases).</span>

<span class="sd">        .. warning::</span>

<span class="sd">           If you prevent ``attrs`` from creating the ordering methods for you</span>
<span class="sd">           (``order=False``, e.g. by implementing ``__le__``), it becomes</span>
<span class="sd">           *your* responsibility to make sure its ordering is sound. The best</span>
<span class="sd">           way is to use the `functools.total_ordering` decorator.</span>


<span class="sd">        Passing ``True`` or ``False`` to *init*, *repr*, *eq*, *order*,</span>
<span class="sd">        *cmp*, or *hash* overrides whatever *auto_detect* would determine.</span>

<span class="sd">        *auto_detect* requires Python 3. Setting it ``True`` on Python 2 raises</span>
<span class="sd">        a `PythonTooOldError`.</span>

<span class="sd">    :param bool repr: Create a ``__repr__`` method with a human readable</span>
<span class="sd">        representation of ``attrs`` attributes..</span>
<span class="sd">    :param bool str: Create a ``__str__`` method that is identical to</span>
<span class="sd">        ``__repr__``.  This is usually not necessary except for</span>
<span class="sd">        `Exception`\ s.</span>
<span class="sd">    :param Optional[bool] eq: If ``True`` or ``None`` (default), add ``__eq__``</span>
<span class="sd">        and ``__ne__`` methods that check two instances for equality.</span>

<span class="sd">        They compare the instances as if they were tuples of their ``attrs``</span>
<span class="sd">        attributes if and only if the types of both classes are *identical*!</span>
<span class="sd">    :param Optional[bool] order: If ``True``, add ``__lt__``, ``__le__``,</span>
<span class="sd">        ``__gt__``, and ``__ge__`` methods that behave like *eq* above and</span>
<span class="sd">        allow instances to be ordered. If ``None`` (default) mirror value of</span>
<span class="sd">        *eq*.</span>
<span class="sd">    :param Optional[bool] cmp: Setting to ``True`` is equivalent to setting</span>
<span class="sd">        ``eq=True, order=True``. Deprecated in favor of *eq* and *order*, has</span>
<span class="sd">        precedence over them for backward-compatibility though. Must not be</span>
<span class="sd">        mixed with *eq* or *order*.</span>
<span class="sd">    :param Optional[bool] hash: If ``None`` (default), the ``__hash__`` method</span>
<span class="sd">        is generated according how *eq* and *frozen* are set.</span>

<span class="sd">        1. If *both* are True, ``attrs`` will generate a ``__hash__`` for you.</span>
<span class="sd">        2. If *eq* is True and *frozen* is False, ``__hash__`` will be set to</span>
<span class="sd">           None, marking it unhashable (which it is).</span>
<span class="sd">        3. If *eq* is False, ``__hash__`` will be left untouched meaning the</span>
<span class="sd">           ``__hash__`` method of the base class will be used (if base class is</span>
<span class="sd">           ``object``, this means it will fall back to id-based hashing.).</span>

<span class="sd">        Although not recommended, you can decide for yourself and force</span>
<span class="sd">        ``attrs`` to create one (e.g. if the class is immutable even though you</span>
<span class="sd">        didn&#39;t freeze it programmatically) by passing ``True`` or not.  Both of</span>
<span class="sd">        these cases are rather special and should be used carefully.</span>

<span class="sd">        See our documentation on `hashing`, Python&#39;s documentation on</span>
<span class="sd">        `object.__hash__`, and the `GitHub issue that led to the default \</span>
<span class="sd">        behavior &lt;https://github.com/python-attrs/attrs/issues/136&gt;`_ for more</span>
<span class="sd">        details.</span>
<span class="sd">    :param bool init: Create a ``__init__`` method that initializes the</span>
<span class="sd">        ``attrs`` attributes.  Leading underscores are stripped for the</span>
<span class="sd">        argument name.  If a ``__attrs_post_init__`` method exists on the</span>
<span class="sd">        class, it will be called after the class is fully initialized.</span>
<span class="sd">    :param bool slots: Create a `slotted class &lt;slotted classes&gt;` that&#39;s more</span>
<span class="sd">        memory-efficient. Slotted classes are generally superior to the default</span>
<span class="sd">        dict classes, but have some gotchas you should know about, so we</span>
<span class="sd">        encourage you to read the `glossary entry &lt;slotted classes&gt;`.</span>
<span class="sd">    :param bool frozen: Make instances immutable after initialization.  If</span>
<span class="sd">        someone attempts to modify a frozen instance,</span>
<span class="sd">        `attr.exceptions.FrozenInstanceError` is raised.</span>

<span class="sd">        .. note::</span>

<span class="sd">            1. This is achieved by installing a custom ``__setattr__`` method</span>
<span class="sd">               on your class, so you can&#39;t implement your own.</span>

<span class="sd">            2. True immutability is impossible in Python.</span>

<span class="sd">            3. This *does* have a minor a runtime performance `impact</span>
<span class="sd">               &lt;how-frozen&gt;` when initializing new instances.  In other words:</span>
<span class="sd">               ``__init__`` is slightly slower with ``frozen=True``.</span>

<span class="sd">            4. If a class is frozen, you cannot modify ``self`` in</span>
<span class="sd">               ``__attrs_post_init__`` or a self-written ``__init__``. You can</span>
<span class="sd">               circumvent that limitation by using</span>
<span class="sd">               ``object.__setattr__(self, &quot;attribute_name&quot;, value)``.</span>

<span class="sd">            5. Subclasses of a frozen class are frozen too.</span>

<span class="sd">    :param bool weakref_slot: Make instances weak-referenceable.  This has no</span>
<span class="sd">        effect unless ``slots`` is also enabled.</span>
<span class="sd">    :param bool auto_attribs: If ``True``, collect `PEP 526`_-annotated</span>
<span class="sd">        attributes (Python 3.6 and later only) from the class body.</span>

<span class="sd">        In this case, you **must** annotate every field.  If ``attrs``</span>
<span class="sd">        encounters a field that is set to an `attr.ib` but lacks a type</span>
<span class="sd">        annotation, an `attr.exceptions.UnannotatedAttributeError` is</span>
<span class="sd">        raised.  Use ``field_name: typing.Any = attr.ib(...)`` if you don&#39;t</span>
<span class="sd">        want to set a type.</span>

<span class="sd">        If you assign a value to those attributes (e.g. ``x: int = 42``), that</span>
<span class="sd">        value becomes the default value like if it were passed using</span>
<span class="sd">        ``attr.ib(default=42)``.  Passing an instance of `Factory` also</span>
<span class="sd">        works as expected.</span>

<span class="sd">        Attributes annotated as `typing.ClassVar`, and attributes that are</span>
<span class="sd">        neither annotated nor set to an `attr.ib` are **ignored**.</span>

<span class="sd">        .. _`PEP 526`: https://www.python.org/dev/peps/pep-0526/</span>
<span class="sd">    :param bool kw_only: Make all attributes keyword-only (Python 3+)</span>
<span class="sd">        in the generated ``__init__`` (if ``init`` is ``False``, this</span>
<span class="sd">        parameter is ignored).</span>
<span class="sd">    :param bool cache_hash: Ensure that the object&#39;s hash code is computed</span>
<span class="sd">        only once and stored on the object.  If this is set to ``True``,</span>
<span class="sd">        hashing must be either explicitly or implicitly enabled for this</span>
<span class="sd">        class.  If the hash code is cached, avoid any reassignments of</span>
<span class="sd">        fields involved in hash code computation or mutations of the objects</span>
<span class="sd">        those fields point to after object creation.  If such changes occur,</span>
<span class="sd">        the behavior of the object&#39;s hash code is undefined.</span>
<span class="sd">    :param bool auto_exc: If the class subclasses `BaseException`</span>
<span class="sd">        (which implicitly includes any subclass of any exception), the</span>
<span class="sd">        following happens to behave like a well-behaved Python exceptions</span>
<span class="sd">        class:</span>

<span class="sd">        - the values for *eq*, *order*, and *hash* are ignored and the</span>
<span class="sd">          instances compare and hash by the instance&#39;s ids (N.B. ``attrs`` will</span>
<span class="sd">          *not* remove existing implementations of ``__hash__`` or the equality</span>
<span class="sd">          methods. It just won&#39;t add own ones.),</span>
<span class="sd">        - all attributes that are either passed into ``__init__`` or have a</span>
<span class="sd">          default value are additionally available as a tuple in the ``args``</span>
<span class="sd">          attribute,</span>
<span class="sd">        - the value of *str* is ignored leaving ``__str__`` to base classes.</span>
<span class="sd">    :param bool collect_by_mro: Setting this to `True` fixes the way ``attrs``</span>
<span class="sd">       collects attributes from base classes.  The default behavior is</span>
<span class="sd">       incorrect in certain cases of multiple inheritance.  It should be on by</span>
<span class="sd">       default but is kept off for backward-compatability.</span>

<span class="sd">       See issue `#428 &lt;https://github.com/python-attrs/attrs/issues/428&gt;`_ for</span>
<span class="sd">       more details.</span>

<span class="sd">    :param Optional[bool] getstate_setstate:</span>
<span class="sd">       .. note::</span>
<span class="sd">          This is usually only interesting for slotted classes and you should</span>
<span class="sd">          probably just set *auto_detect* to `True`.</span>

<span class="sd">       If `True`, ``__getstate__`` and</span>
<span class="sd">       ``__setstate__`` are generated and attached to the class. This is</span>
<span class="sd">       necessary for slotted classes to be pickleable. If left `None`, it&#39;s</span>
<span class="sd">       `True` by default for slotted classes and ``False`` for dict classes.</span>

<span class="sd">       If *auto_detect* is `True`, and *getstate_setstate* is left `None`,</span>
<span class="sd">       and **either** ``__getstate__`` or ``__setstate__`` is detected directly</span>
<span class="sd">       on the class (i.e. not inherited), it is set to `False` (this is usually</span>
<span class="sd">       what you want).</span>

<span class="sd">    :param on_setattr: A callable that is run whenever the user attempts to set</span>
<span class="sd">        an attribute (either by assignment like ``i.x = 42`` or by using</span>
<span class="sd">        `setattr` like ``setattr(i, &quot;x&quot;, 42)``). It receives the same arguments</span>
<span class="sd">        as validators: the instance, the attribute that is being modified, and</span>
<span class="sd">        the new value.</span>

<span class="sd">        If no exception is raised, the attribute is set to the return value of</span>
<span class="sd">        the callable.</span>

<span class="sd">        If a list of callables is passed, they&#39;re automatically wrapped in an</span>
<span class="sd">        `attr.setters.pipe`.</span>

<span class="sd">    :param Optional[callable] field_transformer:</span>
<span class="sd">        A function that is called with the original class object and all</span>
<span class="sd">        fields right before ``attrs`` finalizes the class.  You can use</span>
<span class="sd">        this, e.g., to automatically add converters or validators to</span>
<span class="sd">        fields based on their types.  See `transform-fields` for more details.</span>

<span class="sd">    .. versionadded:: 16.0.0 *slots*</span>
<span class="sd">    .. versionadded:: 16.1.0 *frozen*</span>
<span class="sd">    .. versionadded:: 16.3.0 *str*</span>
<span class="sd">    .. versionadded:: 16.3.0 Support for ``__attrs_post_init__``.</span>
<span class="sd">    .. versionchanged:: 17.1.0</span>
<span class="sd">       *hash* supports ``None`` as value which is also the default now.</span>
<span class="sd">    .. versionadded:: 17.3.0 *auto_attribs*</span>
<span class="sd">    .. versionchanged:: 18.1.0</span>
<span class="sd">       If *these* is passed, no attributes are deleted from the class body.</span>
<span class="sd">    .. versionchanged:: 18.1.0 If *these* is ordered, the order is retained.</span>
<span class="sd">    .. versionadded:: 18.2.0 *weakref_slot*</span>
<span class="sd">    .. deprecated:: 18.2.0</span>
<span class="sd">       ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now raise a</span>
<span class="sd">       `DeprecationWarning` if the classes compared are subclasses of</span>
<span class="sd">       each other. ``__eq`` and ``__ne__`` never tried to compared subclasses</span>
<span class="sd">       to each other.</span>
<span class="sd">    .. versionchanged:: 19.2.0</span>
<span class="sd">       ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now do not consider</span>
<span class="sd">       subclasses comparable anymore.</span>
<span class="sd">    .. versionadded:: 18.2.0 *kw_only*</span>
<span class="sd">    .. versionadded:: 18.2.0 *cache_hash*</span>
<span class="sd">    .. versionadded:: 19.1.0 *auto_exc*</span>
<span class="sd">    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.</span>
<span class="sd">    .. versionadded:: 19.2.0 *eq* and *order*</span>
<span class="sd">    .. versionadded:: 20.1.0 *auto_detect*</span>
<span class="sd">    .. versionadded:: 20.1.0 *collect_by_mro*</span>
<span class="sd">    .. versionadded:: 20.1.0 *getstate_setstate*</span>
<span class="sd">    .. versionadded:: 20.1.0 *on_setattr*</span>
<span class="sd">    .. versionadded:: 20.3.0 *field_transformer*</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">auto_detect</span> <span class="ow">and</span> <span class="n">PY2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">PythonTooOldError</span><span class="p">(</span>
            <span class="s2">&quot;auto_detect only works on Python 3 and later.&quot;</span>
        <span class="p">)</span>

    <span class="n">eq_</span><span class="p">,</span> <span class="n">order_</span> <span class="o">=</span> <span class="n">_determine_eq_order</span><span class="p">(</span><span class="n">cmp</span><span class="p">,</span> <span class="n">eq</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">hash_</span> <span class="o">=</span> <span class="nb">hash</span>  <span class="c1"># work around the lack of nonlocal</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">on_setattr</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">on_setattr</span> <span class="o">=</span> <span class="n">setters</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="o">*</span><span class="n">on_setattr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__class__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;attrs only works with new-style classes.&quot;</span><span class="p">)</span>

        <span class="n">is_frozen</span> <span class="o">=</span> <span class="n">frozen</span> <span class="ow">or</span> <span class="n">_has_frozen_base_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">is_exc</span> <span class="o">=</span> <span class="n">auto_exc</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="ne">BaseException</span><span class="p">)</span>
        <span class="n">has_own_setattr</span> <span class="o">=</span> <span class="n">auto_detect</span> <span class="ow">and</span> <span class="n">_has_own_attribute</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__setattr__&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">has_own_setattr</span> <span class="ow">and</span> <span class="n">is_frozen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t freeze a class with a custom __setattr__.&quot;</span><span class="p">)</span>

        <span class="n">builder</span> <span class="o">=</span> <span class="n">_ClassBuilder</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="n">these</span><span class="p">,</span>
            <span class="n">slots</span><span class="p">,</span>
            <span class="n">is_frozen</span><span class="p">,</span>
            <span class="n">weakref_slot</span><span class="p">,</span>
            <span class="n">_determine_whether_to_implement</span><span class="p">(</span>
                <span class="bp">cls</span><span class="p">,</span>
                <span class="n">getstate_setstate</span><span class="p">,</span>
                <span class="n">auto_detect</span><span class="p">,</span>
                <span class="p">(</span><span class="s2">&quot;__getstate__&quot;</span><span class="p">,</span> <span class="s2">&quot;__setstate__&quot;</span><span class="p">),</span>
                <span class="n">default</span><span class="o">=</span><span class="n">slots</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">auto_attribs</span><span class="p">,</span>
            <span class="n">kw_only</span><span class="p">,</span>
            <span class="n">cache_hash</span><span class="p">,</span>
            <span class="n">is_exc</span><span class="p">,</span>
            <span class="n">collect_by_mro</span><span class="p">,</span>
            <span class="n">on_setattr</span><span class="p">,</span>
            <span class="n">has_own_setattr</span><span class="p">,</span>
            <span class="n">field_transformer</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">_determine_whether_to_implement</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="nb">repr</span><span class="p">,</span> <span class="n">auto_detect</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;__repr__&quot;</span><span class="p">,)</span>
        <span class="p">):</span>
            <span class="n">builder</span><span class="o">.</span><span class="n">add_repr</span><span class="p">(</span><span class="n">repr_ns</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">str</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">builder</span><span class="o">.</span><span class="n">add_str</span><span class="p">()</span>

        <span class="n">eq</span> <span class="o">=</span> <span class="n">_determine_whether_to_implement</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">eq_</span><span class="p">,</span> <span class="n">auto_detect</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;__eq__&quot;</span><span class="p">,</span> <span class="s2">&quot;__ne__&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_exc</span> <span class="ow">and</span> <span class="n">eq</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">builder</span><span class="o">.</span><span class="n">add_eq</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_exc</span> <span class="ow">and</span> <span class="n">_determine_whether_to_implement</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">order_</span><span class="p">,</span> <span class="n">auto_detect</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;__lt__&quot;</span><span class="p">,</span> <span class="s2">&quot;__le__&quot;</span><span class="p">,</span> <span class="s2">&quot;__gt__&quot;</span><span class="p">,</span> <span class="s2">&quot;__ge__&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">builder</span><span class="o">.</span><span class="n">add_order</span><span class="p">()</span>

        <span class="n">builder</span><span class="o">.</span><span class="n">add_setattr</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">hash_</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">auto_detect</span> <span class="ow">is</span> <span class="kc">True</span>
            <span class="ow">and</span> <span class="n">_has_own_attribute</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__hash__&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="nb">hash</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">hash</span> <span class="o">=</span> <span class="n">hash_</span>
        <span class="k">if</span> <span class="nb">hash</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span> <span class="ow">and</span> <span class="nb">hash</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">and</span> <span class="nb">hash</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Can&#39;t use `hash in` because 1 == True for example.</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid value for hash.  Must be True, False, or None.&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hash</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">hash</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">eq</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_exc</span><span class="p">:</span>
            <span class="c1"># Don&#39;t do anything. Should fall back to __object__&#39;s __hash__</span>
            <span class="c1"># which is by id.</span>
            <span class="k">if</span> <span class="n">cache_hash</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid value for cache_hash.  To use hash caching,&quot;</span>
                    <span class="s2">&quot; hashing must be either explicitly or implicitly &quot;</span>
                    <span class="s2">&quot;enabled.&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hash</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="nb">hash</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">eq</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">is_frozen</span> <span class="ow">is</span> <span class="kc">True</span>
        <span class="p">):</span>
            <span class="c1"># Build a __hash__ if told so, or if it&#39;s safe.</span>
            <span class="n">builder</span><span class="o">.</span><span class="n">add_hash</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Raise TypeError on attempts to hash.</span>
            <span class="k">if</span> <span class="n">cache_hash</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid value for cache_hash.  To use hash caching,&quot;</span>
                    <span class="s2">&quot; hashing must be either explicitly or implicitly &quot;</span>
                    <span class="s2">&quot;enabled.&quot;</span>
                <span class="p">)</span>
            <span class="n">builder</span><span class="o">.</span><span class="n">make_unhashable</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">_determine_whether_to_implement</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">auto_detect</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;__init__&quot;</span><span class="p">,)</span>
        <span class="p">):</span>
            <span class="n">builder</span><span class="o">.</span><span class="n">add_init</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cache_hash</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Invalid value for cache_hash.  To use hash caching,&quot;</span>
                    <span class="s2">&quot; init must be True.&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">builder</span><span class="o">.</span><span class="n">build_class</span><span class="p">()</span>

    <span class="c1"># maybe_cls&#39;s type depends on the usage of the decorator.  It&#39;s a class</span>
    <span class="c1"># if it&#39;s used as `@attrs` but ``None`` if used as `@attrs()`.</span>
    <span class="k">if</span> <span class="n">maybe_cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wrap</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">maybe_cls</span><span class="p">)</span>


<span class="n">_attrs</span> <span class="o">=</span> <span class="n">attrs</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Internal alias so we can use it in functions that take an argument called</span>
<span class="sd">*attrs*.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">if</span> <span class="n">PY2</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">_has_frozen_base_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether *cls* has a frozen ancestor by looking at its</span>
<span class="sd">        __setattr__.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">,</span> <span class="s2">&quot;__module__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="o">==</span> <span class="n">_frozen_setattrs</span><span class="o">.</span><span class="vm">__module__</span>
            <span class="ow">and</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__setattr__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="n">_frozen_setattrs</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="p">)</span>


<span class="k">else</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">_has_frozen_base_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether *cls* has a frozen ancestor by looking at its</span>
<span class="sd">        __setattr__.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__setattr__</span> <span class="o">==</span> <span class="n">_frozen_setattrs</span>


<span class="k">def</span> <span class="nf">_attrs_to_tuple</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a tuple of all values of *obj*&#39;s *attrs*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_generate_unique_filename</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">func_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a &quot;filename&quot; suitable for a function being generated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unique_id</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span>
    <span class="n">extra</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">unique_filename</span> <span class="o">=</span> <span class="s2">&quot;&lt;attrs generated </span><span class="si">{0}</span><span class="s2"> </span><span class="si">{1}</span><span class="s2">.</span><span class="si">{2}{3}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">func_name</span><span class="p">,</span>
            <span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span>
            <span class="n">extra</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># To handle concurrency we essentially &quot;reserve&quot; our spot in</span>
        <span class="c1"># the linecache with a dummy line.  The caller can then</span>
        <span class="c1"># set this value correctly.</span>
        <span class="n">cache_line</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">unique_id</span><span class="p">),),</span> <span class="n">unique_filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">linecache</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">unique_filename</span><span class="p">,</span> <span class="n">cache_line</span><span class="p">)</span>
            <span class="o">==</span> <span class="n">cache_line</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">unique_filename</span>

        <span class="c1"># Looks like this spot is taken. Try again.</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="s2">&quot;-</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_make_hash</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">frozen</span><span class="p">,</span> <span class="n">cache_hash</span><span class="p">):</span>
    <span class="n">attrs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">hash</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">hash</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">eq</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">tab</span> <span class="o">=</span> <span class="s2">&quot;        &quot;</span>

    <span class="n">unique_filename</span> <span class="o">=</span> <span class="n">_generate_unique_filename</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;hash&quot;</span><span class="p">)</span>
    <span class="n">type_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">unique_filename</span><span class="p">)</span>

    <span class="n">hash_def</span> <span class="o">=</span> <span class="s2">&quot;def __hash__(self&quot;</span>
    <span class="n">hash_func</span> <span class="o">=</span> <span class="s2">&quot;hash((&quot;</span>
    <span class="n">closing_braces</span> <span class="o">=</span> <span class="s2">&quot;))&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cache_hash</span><span class="p">:</span>
        <span class="n">hash_def</span> <span class="o">+=</span> <span class="s2">&quot;):&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">PY2</span><span class="p">:</span>
            <span class="n">hash_def</span> <span class="o">+=</span> <span class="s2">&quot;, *&quot;</span>

        <span class="n">hash_def</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="s2">&quot;, _cache_wrapper=&quot;</span>
            <span class="o">+</span> <span class="s2">&quot;__import__(&#39;attr._make&#39;)._make._CacheHashWrapper):&quot;</span>
        <span class="p">)</span>
        <span class="n">hash_func</span> <span class="o">=</span> <span class="s2">&quot;_cache_wrapper(&quot;</span> <span class="o">+</span> <span class="n">hash_func</span>
        <span class="n">closing_braces</span> <span class="o">+=</span> <span class="s2">&quot;)&quot;</span>

    <span class="n">method_lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">hash_def</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">append_hash_computation_lines</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">indent</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the code for actually computing the hash code.</span>
<span class="sd">        Below this will either be returned directly or used to compute</span>
<span class="sd">        a value which is then cached, depending on the value of cache_hash</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">method_lines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">indent</span> <span class="o">+</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">hash_func</span><span class="p">,</span>
                <span class="n">indent</span> <span class="o">+</span> <span class="s2">&quot;        </span><span class="si">%d</span><span class="s2">,&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">type_hash</span><span class="p">,),</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="n">method_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="s2">&quot;        self.</span><span class="si">%s</span><span class="s2">,&quot;</span> <span class="o">%</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">method_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="s2">&quot;    &quot;</span> <span class="o">+</span> <span class="n">closing_braces</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cache_hash</span><span class="p">:</span>
        <span class="n">method_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tab</span> <span class="o">+</span> <span class="s2">&quot;if self.</span><span class="si">%s</span><span class="s2"> is None:&quot;</span> <span class="o">%</span> <span class="n">_hash_cache_field</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">frozen</span><span class="p">:</span>
            <span class="n">append_hash_computation_lines</span><span class="p">(</span>
                <span class="s2">&quot;object.__setattr__(self, &#39;</span><span class="si">%s</span><span class="s2">&#39;, &quot;</span> <span class="o">%</span> <span class="n">_hash_cache_field</span><span class="p">,</span> <span class="n">tab</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="p">)</span>
            <span class="n">method_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tab</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">)</span>  <span class="c1"># close __setattr__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">append_hash_computation_lines</span><span class="p">(</span>
                <span class="s2">&quot;self.</span><span class="si">%s</span><span class="s2"> = &quot;</span> <span class="o">%</span> <span class="n">_hash_cache_field</span><span class="p">,</span> <span class="n">tab</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="p">)</span>
        <span class="n">method_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tab</span> <span class="o">+</span> <span class="s2">&quot;return self.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">_hash_cache_field</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">append_hash_computation_lines</span><span class="p">(</span><span class="s2">&quot;return &quot;</span><span class="p">,</span> <span class="n">tab</span><span class="p">)</span>

    <span class="n">script</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">method_lines</span><span class="p">)</span>
    <span class="n">globs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">locs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">bytecode</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">script</span><span class="p">,</span> <span class="n">unique_filename</span><span class="p">,</span> <span class="s2">&quot;exec&quot;</span><span class="p">)</span>
    <span class="nb">eval</span><span class="p">(</span><span class="n">bytecode</span><span class="p">,</span> <span class="n">globs</span><span class="p">,</span> <span class="n">locs</span><span class="p">)</span>

    <span class="c1"># In order of debuggers like PDB being able to step through the code,</span>
    <span class="c1"># we add a fake linecache entry.</span>
    <span class="n">linecache</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">unique_filename</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">script</span><span class="p">),</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">script</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">unique_filename</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">locs</span><span class="p">[</span><span class="s2">&quot;__hash__&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_add_hash</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add a hash method to *cls*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">cls</span><span class="o">.</span><span class="fm">__hash__</span> <span class="o">=</span> <span class="n">_make_hash</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">frozen</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cache_hash</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">cls</span>


<span class="k">def</span> <span class="nf">_make_ne</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create __ne__ method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check equality and either forward a NotImplemented or</span>
<span class="sd">        return the result negated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">return</span> <span class="ow">not</span> <span class="n">result</span>

    <span class="k">return</span> <span class="fm">__ne__</span>


<span class="k">def</span> <span class="nf">_make_eq</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create __eq__ method for *cls* with *attrs*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">eq</span><span class="p">]</span>

    <span class="n">unique_filename</span> <span class="o">=</span> <span class="n">_generate_unique_filename</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;eq&quot;</span><span class="p">)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;def __eq__(self, other):&quot;</span><span class="p">,</span>
        <span class="s2">&quot;    if other.__class__ is not self.__class__:&quot;</span><span class="p">,</span>
        <span class="s2">&quot;        return NotImplemented&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="c1"># We can&#39;t just do a big self.x = other.x and... clause due to</span>
    <span class="c1"># irregularities like nan == nan is false but (nan,) == (nan,) is true.</span>
    <span class="k">if</span> <span class="n">attrs</span><span class="p">:</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;    return  (&quot;</span><span class="p">)</span>
        <span class="n">others</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;    ) == (&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;        self.</span><span class="si">%s</span><span class="s2">,&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">,))</span>
            <span class="n">others</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;        other.</span><span class="si">%s</span><span class="s2">,&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">,))</span>

        <span class="n">lines</span> <span class="o">+=</span> <span class="n">others</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;    )&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;    return True&quot;</span><span class="p">)</span>

    <span class="n">script</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
    <span class="n">globs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">locs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">bytecode</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">script</span><span class="p">,</span> <span class="n">unique_filename</span><span class="p">,</span> <span class="s2">&quot;exec&quot;</span><span class="p">)</span>
    <span class="nb">eval</span><span class="p">(</span><span class="n">bytecode</span><span class="p">,</span> <span class="n">globs</span><span class="p">,</span> <span class="n">locs</span><span class="p">)</span>

    <span class="c1"># In order of debuggers like PDB being able to step through the code,</span>
    <span class="c1"># we add a fake linecache entry.</span>
    <span class="n">linecache</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">unique_filename</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">script</span><span class="p">),</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">script</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">unique_filename</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">locs</span><span class="p">[</span><span class="s2">&quot;__eq__&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_make_order</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create ordering methods for *cls* with *attrs*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">order</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">attrs_to_tuple</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save us some typing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_attrs_to_tuple</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatically created by attrs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">attrs_to_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">attrs_to_tuple</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatically created by attrs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">attrs_to_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">attrs_to_tuple</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatically created by attrs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">attrs_to_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">attrs_to_tuple</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatically created by attrs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="vm">__class__</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">attrs_to_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">attrs_to_tuple</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">return</span> <span class="fm">__lt__</span><span class="p">,</span> <span class="fm">__le__</span><span class="p">,</span> <span class="fm">__gt__</span><span class="p">,</span> <span class="fm">__ge__</span>


<span class="k">def</span> <span class="nf">_add_eq</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add equality methods to *cls* with *attrs*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__attrs_attrs__</span>

    <span class="bp">cls</span><span class="o">.</span><span class="fm">__eq__</span> <span class="o">=</span> <span class="n">_make_eq</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
    <span class="bp">cls</span><span class="o">.</span><span class="fm">__ne__</span> <span class="o">=</span> <span class="n">_make_ne</span><span class="p">()</span>

    <span class="k">return</span> <span class="bp">cls</span>


<span class="n">_already_repring</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">local</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_make_repr</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a repr method that includes relevant *attrs*, adding *ns* to the full</span>
<span class="sd">    name.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Figure out which attributes to include, and which function to use to</span>
    <span class="c1"># format them. The a.repr value can be either bool or a custom callable.</span>
    <span class="n">attr_names_with_reprs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">repr</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">repr</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="n">a</span><span class="o">.</span><span class="n">repr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">repr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatically created by attrs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">working_set</span> <span class="o">=</span> <span class="n">_already_repring</span><span class="o">.</span><span class="n">working_set</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">working_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">_already_repring</span><span class="o">.</span><span class="n">working_set</span> <span class="o">=</span> <span class="n">working_set</span>

        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">working_set</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;...&quot;</span>
        <span class="n">real_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="k">if</span> <span class="n">ns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qualname</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">real_cls</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">qualname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">class_name</span> <span class="o">=</span> <span class="n">qualname</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">&quot;&gt;.&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">class_name</span> <span class="o">=</span> <span class="n">real_cls</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">class_name</span> <span class="o">=</span> <span class="n">ns</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">real_cls</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="c1"># Since &#39;self&#39; remains on the stack (i.e.: strongly referenced) for the</span>
        <span class="c1"># duration of this call, it&#39;s safe to depend on id(...) stability, and</span>
        <span class="c1"># not need to track the instance and therefore worry about properties</span>
        <span class="c1"># like weakref- or hash-ability.</span>
        <span class="n">working_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">class_name</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">]</span>
            <span class="n">first</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr_repr</span> <span class="ow">in</span> <span class="n">attr_names_with_reprs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">first</span><span class="p">:</span>
                    <span class="n">first</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="n">attr_repr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">NOTHING</span><span class="p">)))</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">working_set</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">return</span> <span class="fm">__repr__</span>


<span class="k">def</span> <span class="nf">_add_repr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add a repr method to *cls*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__attrs_attrs__</span>

    <span class="bp">cls</span><span class="o">.</span><span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_make_repr</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">ns</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">cls</span>


<span class="k">def</span> <span class="nf">fields</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the tuple of ``attrs`` attributes for a class.</span>

<span class="sd">    The tuple also allows accessing the fields by their names (see below for</span>
<span class="sd">    examples).</span>

<span class="sd">    :param type cls: Class to introspect.</span>

<span class="sd">    :raise TypeError: If *cls* is not a class.</span>
<span class="sd">    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``</span>
<span class="sd">        class.</span>

<span class="sd">    :rtype: tuple (with name accessors) of `attr.Attribute`</span>

<span class="sd">    ..  versionchanged:: 16.2.0 Returned tuple allows accessing the fields</span>
<span class="sd">        by name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Passed object must be a class.&quot;</span><span class="p">)</span>
    <span class="n">attrs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__attrs_attrs__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">NotAnAttrsClassError</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{cls!r}</span><span class="s2"> is not an attrs-decorated class.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">attrs</span>


<span class="k">def</span> <span class="nf">fields_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an ordered dictionary of ``attrs`` attributes for a class, whose</span>
<span class="sd">    keys are the attribute names.</span>

<span class="sd">    :param type cls: Class to introspect.</span>

<span class="sd">    :raise TypeError: If *cls* is not a class.</span>
<span class="sd">    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``</span>
<span class="sd">        class.</span>

<span class="sd">    :rtype: an ordered dict where keys are attribute names and values are</span>
<span class="sd">        `attr.Attribute`\\ s. This will be a `dict` if it&#39;s</span>
<span class="sd">        naturally ordered like on Python 3.6+ or an</span>
<span class="sd">        :class:`~collections.OrderedDict` otherwise.</span>

<span class="sd">    .. versionadded:: 18.1.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">isclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Passed object must be a class.&quot;</span><span class="p">)</span>
    <span class="n">attrs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__attrs_attrs__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">NotAnAttrsClassError</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{cls!r}</span><span class="s2"> is not an attrs-decorated class.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">ordered_dict</span><span class="p">(((</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="n">inst</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate all attributes on *inst* that have a validator.</span>

<span class="sd">    Leaves all exceptions through.</span>

<span class="sd">    :param inst: Instance of a class with ``attrs`` attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_config</span><span class="o">.</span><span class="n">_run_validators</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">(</span><span class="n">inst</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">validator</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">v</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_is_slot_cls</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;__slots__&quot;</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span>


<span class="k">def</span> <span class="nf">_is_slot_attr</span><span class="p">(</span><span class="n">a_name</span><span class="p">,</span> <span class="n">base_attr_map</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if the attribute name comes from a slot class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">a_name</span> <span class="ow">in</span> <span class="n">base_attr_map</span> <span class="ow">and</span> <span class="n">_is_slot_cls</span><span class="p">(</span><span class="n">base_attr_map</span><span class="p">[</span><span class="n">a_name</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_make_init</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span>
    <span class="n">attrs</span><span class="p">,</span>
    <span class="n">post_init</span><span class="p">,</span>
    <span class="n">frozen</span><span class="p">,</span>
    <span class="n">slots</span><span class="p">,</span>
    <span class="n">cache_hash</span><span class="p">,</span>
    <span class="n">base_attr_map</span><span class="p">,</span>
    <span class="n">is_exc</span><span class="p">,</span>
    <span class="n">has_global_on_setattr</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="n">frozen</span> <span class="ow">and</span> <span class="n">has_global_on_setattr</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Frozen classes can&#39;t use on_setattr.&quot;</span><span class="p">)</span>

    <span class="n">needs_cached_setattr</span> <span class="o">=</span> <span class="n">cache_hash</span> <span class="ow">or</span> <span class="n">frozen</span>
    <span class="n">filtered_attrs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">attr_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">init</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">NOTHING</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">filtered_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">attr_dict</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">on_setattr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">frozen</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Frozen classes can&#39;t use on_setattr.&quot;</span><span class="p">)</span>

            <span class="n">needs_cached_setattr</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">has_global_on_setattr</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">on_setattr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">setters</span><span class="o">.</span><span class="n">NO_OP</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="n">_is_slot_attr</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">base_attr_map</span><span class="p">):</span>
            <span class="n">needs_cached_setattr</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">unique_filename</span> <span class="o">=</span> <span class="n">_generate_unique_filename</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;init&quot;</span><span class="p">)</span>

    <span class="n">script</span><span class="p">,</span> <span class="n">globs</span><span class="p">,</span> <span class="n">annotations</span> <span class="o">=</span> <span class="n">_attrs_to_init_script</span><span class="p">(</span>
        <span class="n">filtered_attrs</span><span class="p">,</span>
        <span class="n">frozen</span><span class="p">,</span>
        <span class="n">slots</span><span class="p">,</span>
        <span class="n">post_init</span><span class="p">,</span>
        <span class="n">cache_hash</span><span class="p">,</span>
        <span class="n">base_attr_map</span><span class="p">,</span>
        <span class="n">is_exc</span><span class="p">,</span>
        <span class="n">needs_cached_setattr</span><span class="p">,</span>
        <span class="n">has_global_on_setattr</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">locs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">bytecode</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">script</span><span class="p">,</span> <span class="n">unique_filename</span><span class="p">,</span> <span class="s2">&quot;exec&quot;</span><span class="p">)</span>
    <span class="n">globs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;NOTHING&quot;</span><span class="p">:</span> <span class="n">NOTHING</span><span class="p">,</span> <span class="s2">&quot;attr_dict&quot;</span><span class="p">:</span> <span class="n">attr_dict</span><span class="p">})</span>

    <span class="k">if</span> <span class="n">needs_cached_setattr</span><span class="p">:</span>
        <span class="c1"># Save the lookup overhead in __init__ if we need to circumvent</span>
        <span class="c1"># setattr hooks.</span>
        <span class="n">globs</span><span class="p">[</span><span class="s2">&quot;_cached_setattr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_obj_setattr</span>

    <span class="nb">eval</span><span class="p">(</span><span class="n">bytecode</span><span class="p">,</span> <span class="n">globs</span><span class="p">,</span> <span class="n">locs</span><span class="p">)</span>

    <span class="c1"># In order of debuggers like PDB being able to step through the code,</span>
    <span class="c1"># we add a fake linecache entry.</span>
    <span class="n">linecache</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">unique_filename</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">script</span><span class="p">),</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="n">script</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">unique_filename</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="fm">__init__</span> <span class="o">=</span> <span class="n">locs</span><span class="p">[</span><span class="s2">&quot;__init__&quot;</span><span class="p">]</span>
    <span class="fm">__init__</span><span class="o">.</span><span class="vm">__annotations__</span> <span class="o">=</span> <span class="n">annotations</span>

    <span class="k">return</span> <span class="fm">__init__</span>


<span class="k">def</span> <span class="nf">_setattr</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">value_var</span><span class="p">,</span> <span class="n">has_on_setattr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use the cached object.setattr to set *attr_name* to *value_var*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;_setattr(&#39;</span><span class="si">%s</span><span class="s2">&#39;, </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">value_var</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_setattr_with_converter</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">value_var</span><span class="p">,</span> <span class="n">has_on_setattr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use the cached object.setattr to set *attr_name* to *value_var*, but run</span>
<span class="sd">    its converter first.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;_setattr(&#39;</span><span class="si">%s</span><span class="s2">&#39;, </span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">))&quot;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">attr_name</span><span class="p">,</span>
        <span class="n">_init_converter_pat</span> <span class="o">%</span> <span class="p">(</span><span class="n">attr_name</span><span class="p">,),</span>
        <span class="n">value_var</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_assign</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">has_on_setattr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unless *attr_name* has an on_setattr hook, use normal assignment. Otherwise</span>
<span class="sd">    relegate to _setattr.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">has_on_setattr</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_setattr</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="s2">&quot;self.</span><span class="si">%s</span><span class="s2"> = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_assign_with_converter</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">value_var</span><span class="p">,</span> <span class="n">has_on_setattr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unless *attr_name* has an on_setattr hook, use normal assignment after</span>
<span class="sd">    conversion. Otherwise relegate to _setattr_with_converter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">has_on_setattr</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_setattr_with_converter</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">value_var</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="s2">&quot;self.</span><span class="si">%s</span><span class="s2"> = </span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">attr_name</span><span class="p">,</span>
        <span class="n">_init_converter_pat</span> <span class="o">%</span> <span class="p">(</span><span class="n">attr_name</span><span class="p">,),</span>
        <span class="n">value_var</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">if</span> <span class="n">PY2</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">_unpack_kw_only_py2</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unpack *attr_name* from _kw_only dict.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arg_default</span> <span class="o">=</span> <span class="s2">&quot;, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">default</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arg_default</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> = _kw_only.pop(&#39;</span><span class="si">%s</span><span class="s2">&#39;</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">attr_name</span><span class="p">,</span>
            <span class="n">attr_name</span><span class="p">,</span>
            <span class="n">arg_default</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_unpack_kw_only_lines_py2</span><span class="p">(</span><span class="n">kw_only_args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unpack all *kw_only_args* from _kw_only dict and handle errors.</span>

<span class="sd">        Given a list of strings &quot;{attr_name}&quot; and &quot;{attr_name}={default}&quot;</span>
<span class="sd">        generates list of lines of code that pop attrs from _kw_only dict and</span>
<span class="sd">        raise TypeError similar to builtin if required attr is missing or</span>
<span class="sd">        extra key is passed.</span>

<span class="sd">        &gt;&gt;&gt; print(&quot;\n&quot;.join(_unpack_kw_only_lines_py2([&quot;a&quot;, &quot;b=42&quot;])))</span>
<span class="sd">        try:</span>
<span class="sd">            a = _kw_only.pop(&#39;a&#39;)</span>
<span class="sd">            b = _kw_only.pop(&#39;b&#39;, 42)</span>
<span class="sd">        except KeyError as _key_error:</span>
<span class="sd">            raise TypeError(</span>
<span class="sd">                ...</span>
<span class="sd">        if _kw_only:</span>
<span class="sd">            raise TypeError(</span>
<span class="sd">                ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;try:&quot;</span><span class="p">]</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="s2">&quot;    &quot;</span> <span class="o">+</span> <span class="n">_unpack_kw_only_py2</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">kw_only_args</span>
        <span class="p">)</span>
        <span class="n">lines</span> <span class="o">+=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">except KeyError as _key_error:</span>
<span class="s2">    raise TypeError(</span>
<span class="s2">        &#39;__init__() missing required keyword-only argument: </span><span class="si">%s</span><span class="s2">&#39; % _key_error</span>
<span class="s2">    )</span>
<span class="s2">if _kw_only:</span>
<span class="s2">    raise TypeError(</span>
<span class="s2">        &#39;__init__() got an unexpected keyword argument </span><span class="si">%r</span><span class="s2">&#39;</span>
<span class="s2">        % next(iter(_kw_only))</span>
<span class="s2">    )</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">lines</span>


<span class="k">def</span> <span class="nf">_attrs_to_init_script</span><span class="p">(</span>
    <span class="n">attrs</span><span class="p">,</span>
    <span class="n">frozen</span><span class="p">,</span>
    <span class="n">slots</span><span class="p">,</span>
    <span class="n">post_init</span><span class="p">,</span>
    <span class="n">cache_hash</span><span class="p">,</span>
    <span class="n">base_attr_map</span><span class="p">,</span>
    <span class="n">is_exc</span><span class="p">,</span>
    <span class="n">needs_cached_setattr</span><span class="p">,</span>
    <span class="n">has_global_on_setattr</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a script of an initializer for *attrs* and a dict of globals.</span>

<span class="sd">    The globals are expected by the generated script.</span>

<span class="sd">    If *frozen* is True, we cannot set the attributes directly so we use</span>
<span class="sd">    a cached ``object.__setattr__``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">needs_cached_setattr</span><span class="p">:</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="c1"># Circumvent the __setattr__ descriptor to save one lookup per</span>
            <span class="c1"># assignment.</span>
            <span class="c1"># Note _setattr will be used again below if cache_hash is True</span>
            <span class="s2">&quot;_setattr = _cached_setattr.__get__(self, self.__class__)&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">frozen</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">slots</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">fmt_setter</span> <span class="o">=</span> <span class="n">_setattr</span>
            <span class="n">fmt_setter_with_converter</span> <span class="o">=</span> <span class="n">_setattr_with_converter</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Dict frozen classes assign directly to __dict__.</span>
            <span class="c1"># But only if the attribute doesn&#39;t come from an ancestor slot</span>
            <span class="c1"># class.</span>
            <span class="c1"># Note _inst_dict will be used again below if cache_hash is True</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;_inst_dict = self.__dict__&quot;</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">fmt_setter</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">value_var</span><span class="p">,</span> <span class="n">has_on_setattr</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">_is_slot_attr</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">base_attr_map</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">_setattr</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">value_var</span><span class="p">,</span> <span class="n">has_on_setattr</span><span class="p">)</span>

                <span class="k">return</span> <span class="s2">&quot;_inst_dict[&#39;</span><span class="si">%s</span><span class="s2">&#39;] = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">value_var</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">fmt_setter_with_converter</span><span class="p">(</span>
                <span class="n">attr_name</span><span class="p">,</span> <span class="n">value_var</span><span class="p">,</span> <span class="n">has_on_setattr</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">has_on_setattr</span> <span class="ow">or</span> <span class="n">_is_slot_attr</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">base_attr_map</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">_setattr_with_converter</span><span class="p">(</span>
                        <span class="n">attr_name</span><span class="p">,</span> <span class="n">value_var</span><span class="p">,</span> <span class="n">has_on_setattr</span>
                    <span class="p">)</span>

                <span class="k">return</span> <span class="s2">&quot;_inst_dict[&#39;</span><span class="si">%s</span><span class="s2">&#39;] = </span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">attr_name</span><span class="p">,</span>
                    <span class="n">_init_converter_pat</span> <span class="o">%</span> <span class="p">(</span><span class="n">attr_name</span><span class="p">,),</span>
                    <span class="n">value_var</span><span class="p">,</span>
                <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Not frozen.</span>
        <span class="n">fmt_setter</span> <span class="o">=</span> <span class="n">_assign</span>
        <span class="n">fmt_setter_with_converter</span> <span class="o">=</span> <span class="n">_assign_with_converter</span>

    <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kw_only_args</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">attrs_to_validate</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># This is a dictionary of names to validator and converter callables.</span>
    <span class="c1"># Injecting this into __init__ globals lets us avoid lookups.</span>
    <span class="n">names_for_globals</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">annotations</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;return&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">validator</span><span class="p">:</span>
            <span class="n">attrs_to_validate</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="n">attr_name</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span>
        <span class="n">has_on_setattr</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">on_setattr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">a</span><span class="o">.</span><span class="n">on_setattr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">setters</span><span class="o">.</span><span class="n">NO_OP</span> <span class="ow">and</span> <span class="n">has_global_on_setattr</span>
        <span class="p">)</span>
        <span class="n">arg_name</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>

        <span class="n">has_factory</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="n">Factory</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">has_factory</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">takes_self</span><span class="p">:</span>
            <span class="n">maybe_self</span> <span class="o">=</span> <span class="s2">&quot;self&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">maybe_self</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">init</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">has_factory</span><span class="p">:</span>
                <span class="n">init_factory_name</span> <span class="o">=</span> <span class="n">_init_factory_pat</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">converter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">fmt_setter_with_converter</span><span class="p">(</span>
                            <span class="n">attr_name</span><span class="p">,</span>
                            <span class="n">init_factory_name</span> <span class="o">+</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">maybe_self</span><span class="p">,),</span>
                            <span class="n">has_on_setattr</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">conv_name</span> <span class="o">=</span> <span class="n">_init_converter_pat</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
                    <span class="n">names_for_globals</span><span class="p">[</span><span class="n">conv_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">converter</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">fmt_setter</span><span class="p">(</span>
                            <span class="n">attr_name</span><span class="p">,</span>
                            <span class="n">init_factory_name</span> <span class="o">+</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">maybe_self</span><span class="p">,),</span>
                            <span class="n">has_on_setattr</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">names_for_globals</span><span class="p">[</span><span class="n">init_factory_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">factory</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">converter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">fmt_setter_with_converter</span><span class="p">(</span>
                            <span class="n">attr_name</span><span class="p">,</span>
                            <span class="s2">&quot;attr_dict[&#39;</span><span class="si">%s</span><span class="s2">&#39;].default&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">attr_name</span><span class="p">,),</span>
                            <span class="n">has_on_setattr</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">conv_name</span> <span class="o">=</span> <span class="n">_init_converter_pat</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
                    <span class="n">names_for_globals</span><span class="p">[</span><span class="n">conv_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">converter</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">fmt_setter</span><span class="p">(</span>
                            <span class="n">attr_name</span><span class="p">,</span>
                            <span class="s2">&quot;attr_dict[&#39;</span><span class="si">%s</span><span class="s2">&#39;].default&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">attr_name</span><span class="p">,),</span>
                            <span class="n">has_on_setattr</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="k">elif</span> <span class="n">a</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">NOTHING</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_factory</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=attr_dict[&#39;</span><span class="si">%s</span><span class="s2">&#39;].default&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg_name</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">kw_only</span><span class="p">:</span>
                <span class="n">kw_only_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">converter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">fmt_setter_with_converter</span><span class="p">(</span>
                        <span class="n">attr_name</span><span class="p">,</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">has_on_setattr</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">names_for_globals</span><span class="p">[</span>
                    <span class="n">_init_converter_pat</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
                <span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">converter</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fmt_setter</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">has_on_setattr</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">has_factory</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=NOTHING&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg_name</span><span class="p">,)</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">kw_only</span><span class="p">:</span>
                <span class="n">kw_only_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;if </span><span class="si">%s</span><span class="s2"> is not NOTHING:&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg_name</span><span class="p">,))</span>

            <span class="n">init_factory_name</span> <span class="o">=</span> <span class="n">_init_factory_pat</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">converter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;    &quot;</span>
                    <span class="o">+</span> <span class="n">fmt_setter_with_converter</span><span class="p">(</span>
                        <span class="n">attr_name</span><span class="p">,</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">has_on_setattr</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;else:&quot;</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;    &quot;</span>
                    <span class="o">+</span> <span class="n">fmt_setter_with_converter</span><span class="p">(</span>
                        <span class="n">attr_name</span><span class="p">,</span>
                        <span class="n">init_factory_name</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="n">maybe_self</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                        <span class="n">has_on_setattr</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">names_for_globals</span><span class="p">[</span>
                    <span class="n">_init_converter_pat</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
                <span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">converter</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;    &quot;</span> <span class="o">+</span> <span class="n">fmt_setter</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">has_on_setattr</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;else:&quot;</span><span class="p">)</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;    &quot;</span>
                    <span class="o">+</span> <span class="n">fmt_setter</span><span class="p">(</span>
                        <span class="n">attr_name</span><span class="p">,</span>
                        <span class="n">init_factory_name</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="n">maybe_self</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                        <span class="n">has_on_setattr</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">names_for_globals</span><span class="p">[</span><span class="n">init_factory_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">factory</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">kw_only</span><span class="p">:</span>
                <span class="n">kw_only_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg_name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">converter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">fmt_setter_with_converter</span><span class="p">(</span>
                        <span class="n">attr_name</span><span class="p">,</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">has_on_setattr</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">names_for_globals</span><span class="p">[</span>
                    <span class="n">_init_converter_pat</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
                <span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">converter</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fmt_setter</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">has_on_setattr</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">init</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">converter</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">annotations</span><span class="p">[</span><span class="n">arg_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span>

    <span class="k">if</span> <span class="n">attrs_to_validate</span><span class="p">:</span>  <span class="c1"># we can skip this if there are no validators.</span>
        <span class="n">names_for_globals</span><span class="p">[</span><span class="s2">&quot;_config&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_config</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;if _config._run_validators is True:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs_to_validate</span><span class="p">:</span>
            <span class="n">val_name</span> <span class="o">=</span> <span class="s2">&quot;__attr_validator_&quot;</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span>
            <span class="n">attr_name</span> <span class="o">=</span> <span class="s2">&quot;__attr_&quot;</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="s2">&quot;    </span><span class="si">%s</span><span class="s2">(self, </span><span class="si">%s</span><span class="s2">, self.</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">val_name</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">names_for_globals</span><span class="p">[</span><span class="n">val_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">validator</span>
            <span class="n">names_for_globals</span><span class="p">[</span><span class="n">attr_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>

    <span class="k">if</span> <span class="n">post_init</span><span class="p">:</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;self.__attrs_post_init__()&quot;</span><span class="p">)</span>

    <span class="c1"># because this is set only after __attrs_post_init is called, a crash</span>
    <span class="c1"># will result if post-init tries to access the hash code.  This seemed</span>
    <span class="c1"># preferable to setting this beforehand, in which case alteration to</span>
    <span class="c1"># field values during post-init combined with post-init accessing the</span>
    <span class="c1"># hash code would result in silent bugs.</span>
    <span class="k">if</span> <span class="n">cache_hash</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">frozen</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">slots</span><span class="p">:</span>
                <span class="c1"># if frozen and slots, then _setattr defined above</span>
                <span class="n">init_hash_cache</span> <span class="o">=</span> <span class="s2">&quot;_setattr(&#39;</span><span class="si">%s</span><span class="s2">&#39;, </span><span class="si">%s</span><span class="s2">)&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if frozen and not slots, then _inst_dict defined above</span>
                <span class="n">init_hash_cache</span> <span class="o">=</span> <span class="s2">&quot;_inst_dict[&#39;</span><span class="si">%s</span><span class="s2">&#39;] = </span><span class="si">%s</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">init_hash_cache</span> <span class="o">=</span> <span class="s2">&quot;self.</span><span class="si">%s</span><span class="s2"> = </span><span class="si">%s</span><span class="s2">&quot;</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">init_hash_cache</span> <span class="o">%</span> <span class="p">(</span><span class="n">_hash_cache_field</span><span class="p">,</span> <span class="s2">&quot;None&quot;</span><span class="p">))</span>

    <span class="c1"># For exceptions we rely on BaseException.__init__ for proper</span>
    <span class="c1"># initialization.</span>
    <span class="k">if</span> <span class="n">is_exc</span><span class="p">:</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;self.&quot;</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">init</span><span class="p">)</span>

        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;BaseException.__init__(self, </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vals</span><span class="p">,))</span>

    <span class="n">args</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kw_only_args</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">PY2</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">_unpack_kw_only_lines_py2</span><span class="p">(</span><span class="n">kw_only_args</span><span class="p">)</span> <span class="o">+</span> <span class="n">lines</span>

            <span class="n">args</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">**_kw_only&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;, &quot;</span> <span class="k">if</span> <span class="n">args</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,)</span>  <span class="c1"># leading comma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">*, </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="s2">&quot;, &quot;</span> <span class="k">if</span> <span class="n">args</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>  <span class="c1"># leading comma</span>
                <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">kw_only_args</span><span class="p">),</span>  <span class="c1"># kw_only args</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">def __init__(self, {args}):</span>
<span class="sd">    {lines}</span>
<span class="sd">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">lines</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span> <span class="k">if</span> <span class="n">lines</span> <span class="k">else</span> <span class="s2">&quot;pass&quot;</span>
        <span class="p">),</span>
        <span class="n">names_for_globals</span><span class="p">,</span>
        <span class="n">annotations</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">class</span> <span class="nc">Attribute</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    *Read-only* representation of an attribute.</span>

<span class="sd">    Instances of this class are frequently used for introspection purposes</span>
<span class="sd">    like:</span>

<span class="sd">    - `fields` returns a tuple of them.</span>
<span class="sd">    - Validators get them passed as the first argument.</span>
<span class="sd">    - The *field transformer* hook receives a list of them.</span>

<span class="sd">    :attribute name: The name of the attribute.</span>
<span class="sd">    :attribute inherited: Whether or not that attribute has been inherited from</span>
<span class="sd">        a base class.</span>

<span class="sd">    Plus *all* arguments of `attr.ib` (except for ``factory``</span>
<span class="sd">    which is only syntactic sugar for ``default=Factory(...)``.</span>

<span class="sd">    .. versionadded:: 20.1.0 *inherited*</span>
<span class="sd">    .. versionadded:: 20.1.0 *on_setattr*</span>
<span class="sd">    .. versionchanged:: 20.2.0 *inherited* is not taken into account for</span>
<span class="sd">        equality checks and hashing anymore.</span>

<span class="sd">    For the full version history of the fields, see `attr.ib`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;default&quot;</span><span class="p">,</span>
        <span class="s2">&quot;validator&quot;</span><span class="p">,</span>
        <span class="s2">&quot;repr&quot;</span><span class="p">,</span>
        <span class="s2">&quot;eq&quot;</span><span class="p">,</span>
        <span class="s2">&quot;order&quot;</span><span class="p">,</span>
        <span class="s2">&quot;hash&quot;</span><span class="p">,</span>
        <span class="s2">&quot;init&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;type&quot;</span><span class="p">,</span>
        <span class="s2">&quot;converter&quot;</span><span class="p">,</span>
        <span class="s2">&quot;kw_only&quot;</span><span class="p">,</span>
        <span class="s2">&quot;inherited&quot;</span><span class="p">,</span>
        <span class="s2">&quot;on_setattr&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">default</span><span class="p">,</span>
        <span class="n">validator</span><span class="p">,</span>
        <span class="nb">repr</span><span class="p">,</span>
        <span class="n">cmp</span><span class="p">,</span>  <span class="c1"># XXX: unused, remove along with other cmp code.</span>
        <span class="nb">hash</span><span class="p">,</span>
        <span class="n">init</span><span class="p">,</span>
        <span class="n">inherited</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">converter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">kw_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">eq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">on_setattr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">eq</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">_determine_eq_order</span><span class="p">(</span><span class="n">cmp</span><span class="p">,</span> <span class="n">eq</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Cache this descriptor here to speed things up later.</span>
        <span class="n">bound_setattr</span> <span class="o">=</span> <span class="n">_obj_setattr</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Attribute</span><span class="p">)</span>

        <span class="c1"># Despite the big red warning, people *do* instantiate `Attribute`</span>
        <span class="c1"># themselves.</span>
        <span class="n">bound_setattr</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">bound_setattr</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
        <span class="n">bound_setattr</span><span class="p">(</span><span class="s2">&quot;validator&quot;</span><span class="p">,</span> <span class="n">validator</span><span class="p">)</span>
        <span class="n">bound_setattr</span><span class="p">(</span><span class="s2">&quot;repr&quot;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">)</span>
        <span class="n">bound_setattr</span><span class="p">(</span><span class="s2">&quot;eq&quot;</span><span class="p">,</span> <span class="n">eq</span><span class="p">)</span>
        <span class="n">bound_setattr</span><span class="p">(</span><span class="s2">&quot;order&quot;</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="n">bound_setattr</span><span class="p">(</span><span class="s2">&quot;hash&quot;</span><span class="p">,</span> <span class="nb">hash</span><span class="p">)</span>
        <span class="n">bound_setattr</span><span class="p">(</span><span class="s2">&quot;init&quot;</span><span class="p">,</span> <span class="n">init</span><span class="p">)</span>
        <span class="n">bound_setattr</span><span class="p">(</span><span class="s2">&quot;converter&quot;</span><span class="p">,</span> <span class="n">converter</span><span class="p">)</span>
        <span class="n">bound_setattr</span><span class="p">(</span>
            <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
            <span class="p">(</span>
                <span class="n">metadata_proxy</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">metadata</span>
                <span class="k">else</span> <span class="n">_empty_metadata_singleton</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="n">bound_setattr</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
        <span class="n">bound_setattr</span><span class="p">(</span><span class="s2">&quot;kw_only&quot;</span><span class="p">,</span> <span class="n">kw_only</span><span class="p">)</span>
        <span class="n">bound_setattr</span><span class="p">(</span><span class="s2">&quot;inherited&quot;</span><span class="p">,</span> <span class="n">inherited</span><span class="p">)</span>
        <span class="n">bound_setattr</span><span class="p">(</span><span class="s2">&quot;on_setattr&quot;</span><span class="p">,</span> <span class="n">on_setattr</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">FrozenInstanceError</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_counting_attr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ca</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># type holds the annotated value. deal with conflicts:</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">type</span>
        <span class="k">elif</span> <span class="n">ca</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Type annotation and type argument cannot both be present&quot;</span>
            <span class="p">)</span>
        <span class="n">inst_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Attribute</span><span class="o">.</span><span class="vm">__slots__</span>
            <span class="k">if</span> <span class="n">k</span>
            <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="s2">&quot;name&quot;</span><span class="p">,</span>
                <span class="s2">&quot;validator&quot;</span><span class="p">,</span>
                <span class="s2">&quot;default&quot;</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">,</span>
                <span class="s2">&quot;inherited&quot;</span><span class="p">,</span>
            <span class="p">)</span>  <span class="c1"># exclude methods and deprecated alias</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">validator</span><span class="o">=</span><span class="n">ca</span><span class="o">.</span><span class="n">_validator</span><span class="p">,</span>
            <span class="n">default</span><span class="o">=</span><span class="n">ca</span><span class="o">.</span><span class="n">_default</span><span class="p">,</span>
            <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
            <span class="n">cmp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">inherited</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">inst_dict</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cmp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate the presence of a cmp attribute and warn.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">_CMP_DEPRECATION</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span>

    <span class="c1"># Don&#39;t use attr.evolve since fields(Attribute) doesn&#39;t work</span>
    <span class="k">def</span> <span class="nf">evolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">changes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy *self* and apply *changes*.</span>

<span class="sd">        This works similarly to `attr.evolve` but that function does not work</span>
<span class="sd">        with ``Attribute``.</span>

<span class="sd">        It is mainly meant to be used for `transform-fields`.</span>

<span class="sd">        .. versionadded:: 20.3.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">new</span><span class="o">.</span><span class="n">_setattrs</span><span class="p">(</span><span class="n">changes</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">new</span>

    <span class="c1"># Don&#39;t use _add_pickle since fields(Attribute) doesn&#39;t work</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Play nice with pickle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;metadata&quot;</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Play nice with pickle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setattrs</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_setattrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_values_pairs</span><span class="p">):</span>
        <span class="n">bound_setattr</span> <span class="o">=</span> <span class="n">_obj_setattr</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Attribute</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">name_values_pairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;metadata&quot;</span><span class="p">:</span>
                <span class="n">bound_setattr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bound_setattr</span><span class="p">(</span>
                    <span class="n">name</span><span class="p">,</span>
                    <span class="n">metadata_proxy</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">value</span>
                    <span class="k">else</span> <span class="n">_empty_metadata_singleton</span><span class="p">,</span>
                <span class="p">)</span>


<span class="n">_a</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">Attribute</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="n">NOTHING</span><span class="p">,</span>
        <span class="n">validator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">repr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">cmp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">eq</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="nb">hash</span><span class="o">=</span><span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;metadata&quot;</span><span class="p">),</span>
        <span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">inherited</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">Attribute</span><span class="o">.</span><span class="vm">__slots__</span>
<span class="p">]</span>

<span class="n">Attribute</span> <span class="o">=</span> <span class="n">_add_hash</span><span class="p">(</span>
    <span class="n">_add_eq</span><span class="p">(</span>
        <span class="n">_add_repr</span><span class="p">(</span><span class="n">Attribute</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="n">_a</span><span class="p">),</span>
        <span class="n">attrs</span><span class="o">=</span><span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">_a</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;inherited&quot;</span><span class="p">],</span>
    <span class="p">),</span>
    <span class="n">attrs</span><span class="o">=</span><span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">_a</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">hash</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;inherited&quot;</span><span class="p">],</span>
<span class="p">)</span>


<span class="k">class</span> <span class="nc">_CountingAttr</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Intermediate representation of attributes that uses a counter to preserve</span>
<span class="sd">    the order in which the attributes have been defined.</span>

<span class="sd">    *Internal* data structure of the attrs library.  Running into is most</span>
<span class="sd">    likely the result of a bug like a forgotten `@attr.s` decorator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;counter&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_default&quot;</span><span class="p">,</span>
        <span class="s2">&quot;repr&quot;</span><span class="p">,</span>
        <span class="s2">&quot;eq&quot;</span><span class="p">,</span>
        <span class="s2">&quot;order&quot;</span><span class="p">,</span>
        <span class="s2">&quot;hash&quot;</span><span class="p">,</span>
        <span class="s2">&quot;init&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_validator&quot;</span><span class="p">,</span>
        <span class="s2">&quot;converter&quot;</span><span class="p">,</span>
        <span class="s2">&quot;type&quot;</span><span class="p">,</span>
        <span class="s2">&quot;kw_only&quot;</span><span class="p">,</span>
        <span class="s2">&quot;on_setattr&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">__attrs_attrs__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="n">Attribute</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">default</span><span class="o">=</span><span class="n">NOTHING</span><span class="p">,</span>
            <span class="n">validator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="nb">repr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">cmp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="nb">hash</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">kw_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">eq</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">inherited</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">on_setattr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="s2">&quot;counter&quot;</span><span class="p">,</span>
            <span class="s2">&quot;_default&quot;</span><span class="p">,</span>
            <span class="s2">&quot;repr&quot;</span><span class="p">,</span>
            <span class="s2">&quot;eq&quot;</span><span class="p">,</span>
            <span class="s2">&quot;order&quot;</span><span class="p">,</span>
            <span class="s2">&quot;hash&quot;</span><span class="p">,</span>
            <span class="s2">&quot;init&quot;</span><span class="p">,</span>
            <span class="s2">&quot;on_setattr&quot;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span> <span class="o">+</span> <span class="p">(</span>
        <span class="n">Attribute</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
            <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">validator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="nb">repr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">cmp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="nb">hash</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">init</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">kw_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">eq</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">inherited</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">on_setattr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="n">cls_counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">default</span><span class="p">,</span>
        <span class="n">validator</span><span class="p">,</span>
        <span class="nb">repr</span><span class="p">,</span>
        <span class="n">cmp</span><span class="p">,</span>  <span class="c1"># XXX: unused, remove along with cmp</span>
        <span class="nb">hash</span><span class="p">,</span>
        <span class="n">init</span><span class="p">,</span>
        <span class="n">converter</span><span class="p">,</span>
        <span class="n">metadata</span><span class="p">,</span>
        <span class="nb">type</span><span class="p">,</span>
        <span class="n">kw_only</span><span class="p">,</span>
        <span class="n">eq</span><span class="p">,</span>
        <span class="n">order</span><span class="p">,</span>
        <span class="n">on_setattr</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">_CountingAttr</span><span class="o">.</span><span class="n">cls_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="n">_CountingAttr</span><span class="o">.</span><span class="n">cls_counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default</span> <span class="o">=</span> <span class="n">default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validator</span> <span class="o">=</span> <span class="n">validator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converter</span> <span class="o">=</span> <span class="n">converter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repr</span> <span class="o">=</span> <span class="nb">repr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hash</span> <span class="o">=</span> <span class="nb">hash</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init</span> <span class="o">=</span> <span class="n">init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kw_only</span> <span class="o">=</span> <span class="n">kw_only</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_setattr</span> <span class="o">=</span> <span class="n">on_setattr</span>

    <span class="k">def</span> <span class="nf">validator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meth</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decorator that adds *meth* to the list of validators.</span>

<span class="sd">        Returns *meth* unchanged.</span>

<span class="sd">        .. versionadded:: 17.1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validator</span> <span class="o">=</span> <span class="n">meth</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validator</span> <span class="o">=</span> <span class="n">and_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_validator</span><span class="p">,</span> <span class="n">meth</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">meth</span>

    <span class="k">def</span> <span class="nf">default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meth</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decorator that allows to set the default for an attribute.</span>

<span class="sd">        Returns *meth* unchanged.</span>

<span class="sd">        :raises DefaultAlreadySetError: If default has been set before.</span>

<span class="sd">        .. versionadded:: 17.1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">NOTHING</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DefaultAlreadySetError</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_default</span> <span class="o">=</span> <span class="n">Factory</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="n">takes_self</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">meth</span>


<span class="n">_CountingAttr</span> <span class="o">=</span> <span class="n">_add_eq</span><span class="p">(</span><span class="n">_add_repr</span><span class="p">(</span><span class="n">_CountingAttr</span><span class="p">))</span>


<span class="nd">@attrs</span><span class="p">(</span><span class="n">slots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Factory</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stores a factory callable.</span>

<span class="sd">    If passed as the default value to `attr.ib`, the factory is used to</span>
<span class="sd">    generate a new value.</span>

<span class="sd">    :param callable factory: A callable that takes either none or exactly one</span>
<span class="sd">        mandatory positional argument depending on *takes_self*.</span>
<span class="sd">    :param bool takes_self: Pass the partially initialized instance that is</span>
<span class="sd">        being initialized as a positional argument.</span>

<span class="sd">    .. versionadded:: 17.1.0  *takes_self*</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">factory</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>
    <span class="n">takes_self</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factory</span><span class="p">,</span> <span class="n">takes_self</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        `Factory` is part of the default machinery so if we want a default</span>
<span class="sd">        value here, we have to implement it ourselves.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factory</span> <span class="o">=</span> <span class="n">factory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">takes_self</span> <span class="o">=</span> <span class="n">takes_self</span>


<span class="k">def</span> <span class="nf">make_class</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="o">**</span><span class="n">attributes_arguments</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A quick way to create a new class called *name* with *attrs*.</span>

<span class="sd">    :param str name: The name for the new class.</span>

<span class="sd">    :param attrs: A list of names or a dictionary of mappings of names to</span>
<span class="sd">        attributes.</span>

<span class="sd">        If *attrs* is a list or an ordered dict (`dict` on Python 3.6+,</span>
<span class="sd">        `collections.OrderedDict` otherwise), the order is deduced from</span>
<span class="sd">        the order of the names or attributes inside *attrs*.  Otherwise the</span>
<span class="sd">        order of the definition of the attributes is used.</span>
<span class="sd">    :type attrs: `list` or `dict`</span>

<span class="sd">    :param tuple bases: Classes that the new class will subclass.</span>

<span class="sd">    :param attributes_arguments: Passed unmodified to `attr.s`.</span>

<span class="sd">    :return: A new class with *attrs*.</span>
<span class="sd">    :rtype: type</span>

<span class="sd">    .. versionadded:: 17.1.0 *bases*</span>
<span class="sd">    .. versionchanged:: 18.1.0 If *attrs* is ordered, the order is retained.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">cls_dict</span> <span class="o">=</span> <span class="n">attrs</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">cls_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">attrib</span><span class="p">())</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;attrs argument must be a dict or a list.&quot;</span><span class="p">)</span>

    <span class="n">post_init</span> <span class="o">=</span> <span class="n">cls_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;__attrs_post_init__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">type_</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">bases</span><span class="p">,</span>
        <span class="p">{}</span> <span class="k">if</span> <span class="n">post_init</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{</span><span class="s2">&quot;__attrs_post_init__&quot;</span><span class="p">:</span> <span class="n">post_init</span><span class="p">},</span>
    <span class="p">)</span>
    <span class="c1"># For pickling to work, the __module__ variable needs to be set to the</span>
    <span class="c1"># frame where the class is created.  Bypass this step in environments where</span>
    <span class="c1"># sys._getframe is not defined (Jython for example) or sys._getframe is not</span>
    <span class="c1"># defined for arguments greater than 0 (IronPython).</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">type_</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">f_globals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="s2">&quot;__main__&quot;</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="c1"># We do it here for proper warnings with meaningful stacklevel.</span>
    <span class="n">cmp</span> <span class="o">=</span> <span class="n">attributes_arguments</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;cmp&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="p">(</span>
        <span class="n">attributes_arguments</span><span class="p">[</span><span class="s2">&quot;eq&quot;</span><span class="p">],</span>
        <span class="n">attributes_arguments</span><span class="p">[</span><span class="s2">&quot;order&quot;</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">=</span> <span class="n">_determine_eq_order</span><span class="p">(</span>
        <span class="n">cmp</span><span class="p">,</span>
        <span class="n">attributes_arguments</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;eq&quot;</span><span class="p">),</span>
        <span class="n">attributes_arguments</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;order&quot;</span><span class="p">),</span>
        <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">_attrs</span><span class="p">(</span><span class="n">these</span><span class="o">=</span><span class="n">cls_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">attributes_arguments</span><span class="p">)(</span><span class="n">type_</span><span class="p">)</span>


<span class="c1"># These are required by within this module so we define them here and merely</span>
<span class="c1"># import into .validators / .converters.</span>


<span class="nd">@attrs</span><span class="p">(</span><span class="n">slots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">hash</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">_AndValidator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compose many validators to a single one.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_validators</span> <span class="o">=</span> <span class="n">attrib</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validators</span><span class="p">:</span>
            <span class="n">v</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">and_</span><span class="p">(</span><span class="o">*</span><span class="n">validators</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A validator that composes multiple validators into one.</span>

<span class="sd">    When called on a value, it runs all wrapped validators.</span>

<span class="sd">    :param callables validators: Arbitrary number of validators.</span>

<span class="sd">    .. versionadded:: 17.1.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">validator</span> <span class="ow">in</span> <span class="n">validators</span><span class="p">:</span>
        <span class="n">vals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="n">validator</span><span class="o">.</span><span class="n">_validators</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">validator</span><span class="p">,</span> <span class="n">_AndValidator</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">[</span><span class="n">validator</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">_AndValidator</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">vals</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">pipe</span><span class="p">(</span><span class="o">*</span><span class="n">converters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A converter that composes multiple converters into one.</span>

<span class="sd">    When called on a value, it runs all wrapped converters, returning the</span>
<span class="sd">    *last* value.</span>

<span class="sd">    :param callables converters: Arbitrary number of converters.</span>

<span class="sd">    .. versionadded:: 20.1.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">pipe_converter</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">converter</span> <span class="ow">in</span> <span class="n">converters</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">converter</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">val</span>

    <span class="k">return</span> <span class="n">pipe_converter</span>
</pre></div>

              </div>
              
              
              <div class='prev-next-bottom'>
                

              </div>
              
          </main>
          

      </div>
    </div>

    
  <script src="../../_static/js/index.d3f166471bb80abb5163.js"></script>


    <footer class="footer mt-5 mt-md-0">
  <div class="container">
    <p>
          &copy; Copyright 2020, Dustin Tindall.<br/>
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.4.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>